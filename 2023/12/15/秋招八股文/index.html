

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Banned104">
  <meta name="keywords" content="">
  
    <meta name="description" content="写的非常乱，有空整理下… 【基础知识&amp;刷题&amp;项目描述】C语言刷题 【江波龙】enum：   用内存的角度进行思考；   如果成员中有一个没有定义值，那么就是其上一个成员值+1；     【江波龙】判断是否为死循环：int k &#x3D; 0; do{ k++; }while( k ≥ 0 ); ;k会溢出 变为负数；   12345678void func( void )&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式秋招八股文">
<meta property="og:url" content="http://example.com/2023/12/15/%E7%A7%8B%E6%8B%9B%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="写的非常乱，有空整理下… 【基础知识&amp;刷题&amp;项目描述】C语言刷题 【江波龙】enum：   用内存的角度进行思考；   如果成员中有一个没有定义值，那么就是其上一个成员值+1；     【江波龙】判断是否为死循环：int k &#x3D; 0; do{ k++; }while( k ≥ 0 ); ;k会溢出 变为负数；   12345678void func( void )&amp;#12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%201.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%202.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%203.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%204.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%205.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%206.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%207.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%208.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%209.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2010.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2011.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2012.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2013.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2014.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2015.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2016.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2017.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2018.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2019.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2020.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2021.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2022.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2023.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2024.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2025.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2026.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201014180756913.png?x-oss-process=image/resize,m_fixed,h_64,w_64">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201107155006691.gif#pic_center">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2027.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2028.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2029.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2030.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2031.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2032.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2033.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2034.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2035.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2036.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2037.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2038.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2039.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2040.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2041.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2042.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a3c1bfd93274455f9cb66a05ba476770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5MjE3Mjk3,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2043.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2044.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2045.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2046.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2047.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2048.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2049.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2050.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2051.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2052.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2053.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2054.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2055.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2056.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2057.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2058.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2059.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2060.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2061.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2062.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2063.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2064.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2065.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190927151132530.png?x-oss-process=image/resize,m_fixed,h_224,w_224">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2066.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2067.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2068.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2069.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2070.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2071.png">
<meta property="og:image" content="https://s2.51cto.com/images/blog/202211/13105135_63705bb74f1b356639.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=,x-oss-process=image/resize,m_fixed,w_1184/format,webp">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2072.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/1f6eec8d13b419ca7a74e58a99db4b02.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ab3c745ffab408d6f09f8c2a9e4bd522.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/ea769da6abd4ca277e4648b34f61f500.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f706071b5bd1753aeb1c91fd50bcf11b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/a5b2c1925a9b1edd89270eb744f6d641.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2073.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2074.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2075.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2076.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201014180756925.png?x-oss-process=image/resize,m_fixed,h_64,w_64">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190716142538298.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70,">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190716150058934.jpg?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190716152103809.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019071615215887.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190716163248670.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190716170149616.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190716170311270.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2077.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2078.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2079.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2080.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2081.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200705155925993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY3MjA5NA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2082.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2083.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2084.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2085.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2086.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2087.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2088.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2089.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2090.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2091.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2092.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2093.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2094.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2095.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-c76c904423532fcd2f4c9eb24c5069f9_720w.webp">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2096.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6c16b72b4ca04cb389bac848116f8428.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_13,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b620a0a2412e4c3792e56a251e760d83.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_18,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e40c0ec78953486e82fac4fa404f049d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/eedf04a26b46483da6d845b3a818512f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a767f5a8f44345838cb27ea7ccc3ce02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201103011946638.png#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/99abbf68f67d4d2f81ea11f33057f8b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/803592f691cd4196b869e181204950db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b5c18d98920c4e4db32066ed1aead178.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_19,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0f18cc37030a4f06a78f00ee22ed0b69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_19,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2097.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2098.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2099.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20100.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20101.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20102.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20103.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020073111090647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020080309141094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200803092737290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20104.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20105.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20106.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20107.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20108.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20109.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20110.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20111.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20112.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20113.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201014180756916.png?x-oss-process=image/resize,m_fixed,h_64,w_64">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20114.png">
<meta property="og:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/%25E6%259B%25BF%25E6%258D%25A2%25E7%25A9%25BA%25E6%25A0%25BC.gif">
<meta property="article:published_time" content="2023-12-15T15:39:11.217Z">
<meta property="article:modified_time" content="2023-12-15T15:55:17.930Z">
<meta property="article:author" content="Banned104">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled.png">
  
  
  
  <title>嵌入式秋招八股文 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="嵌入式秋招八股文"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-15 23:39" pubdate>
          December 15, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.4k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          46 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">嵌入式秋招八股文</h1>
            
            
              <div class="markdown-body">
                
                <p>写的非常乱，有空整理下…</p>
<h1 id="【基础知识-刷题-项目描述】"><a href="#【基础知识-刷题-项目描述】" class="headerlink" title="【基础知识&amp;刷题&amp;项目描述】"></a>【基础知识&amp;刷题&amp;项目描述】</h1><h3 id="C语言刷题"><a href="#C语言刷题" class="headerlink" title="C语言刷题"></a>C语言刷题</h3><ul>
<li><p>【江波龙】enum：</p>
<p>  用内存的角度进行思考；</p>
<p>  如果成员中有一个没有定义值，那么就是其上一个成员值+1；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【江波龙】判断是否为死循环：int k &#x3D; 0; do{ k++; }while( k ≥ 0 ); ;k会溢出 变为负数；</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        k++;<br>        <span class="hljs-comment">// cout &lt;&lt; k &lt;&lt; &quot;\t&quot;;</span><br>    &#125;<span class="hljs-keyword">while</span>( k &gt;= <span class="hljs-number">0</span> );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>printf输出浮点数问题：</p>
<ul>
<li><p>1 %3.0f，即不输出小数位</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%202.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>赋值表达式问题：while( k&#x3D;0 )  k++;  <strong>赋值语句返回值为所附的值</strong>，如果while中换成k&#x3D;1则死循环</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%203.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>赋值表达式问题：【a&#x3D;(b&#x3D;(c&#x3D;2，d&#x3D;3))； 逗号表达式返回的是第二个赋值语句的值；】————【a／b&#x3D;2；等于号的优先级最低，先执行a&#x2F;b; 然后变为一个常量，常量不能赋值给常量 】</p>
<ul>
<li><strong>A选项</strong>为逗号表达式，即先算表达式1，后算表达式2，整个表达式为表达式2的值，所以原式可以分解为：c&#x3D;2,b&#x3D;d,d&#x3D;3,a&#x3D;b</li>
<li><strong>B选项</strong>为单目自加运算，整合为i&#x3D;i+1</li>
<li><strong>C选项</strong>a&#x2F;b为一个表达式，不可以被赋值为具体的数字。<strong>所以C错误</strong>。</li>
<li><strong>D选项</strong>根据运算符号优先级，先计算a+1,在计算&gt;a为true，转为1，即a&#x3D;1</li>
</ul>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%204.png" srcset="/img/loading.gif" lazyload alt="Untitled">
  </p>
</li>
<li><p>运算符表达式合法性：a&#x3D;b&#x3D;c+2; (√)；   a&#x3D;a+7&#x3D;c+b;(x)</p>
<p>  说说D吧，a+7只能作为右值，而这里把它当做了左值，所以D是不对的</p>
<p>  B B是对的 但如果定义时 int a &#x3D; b &#x3D; c + 2;这样是错的; 只定义了a没定义b;</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%205.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【运算符优先级】【或运算左边成立时不需要执行右边】【取反若不为零直接置0】**!(a + b) - c + 1 || c + b &#x2F; 2**</p>
<p>  运算符优先级：||最后运算，先算！（a+b）结果为0，（0-c+1）&#x3D;-3不为0，即前半部分（||左边）结果为1，右半部分事实上不用计算。 </p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%206.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>给一个数字取反直接得0 [gcc]【区分逻辑取反!  和按位取反～】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%207.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【按位与运算符 1&amp;2&#x3D;&#x3D;0】**<code>printf**(&quot;%d\n&quot;,a/b&amp;c);</code></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%208.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%209.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>操作符优先级问题：p+&#x3D;2,<em>p++；  ++优先级高于</em>；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2010.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>真的是越来越逆天了：<code>printf(&quot;%s, &quot;, *--*++ppa+3);</code>  【多级指针 没弄明白】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2011.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2012.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <strong>下列代码输出是（）</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *a[] = &#123;<span class="hljs-string">&quot;BEIJING&quot;</span>, <span class="hljs-string">&quot;SHENZHEN&quot;</span>, <span class="hljs-string">&quot;SHANGHAI&quot;</span>, <span class="hljs-string">&quot;GUANGZHOU&quot;</span>&#125;;<br><span class="hljs-type">char</span> **pa[] = &#123;a+<span class="hljs-number">3</span>, a+<span class="hljs-number">2</span>, a+<span class="hljs-number">1</span>, a&#125;;<br><span class="hljs-type">char</span> ***ppa = pa;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, &quot;</span>, **++ppa);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, &quot;</span>, *--*++ppa+<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, &quot;</span>, *ppa[<span class="hljs-number">-2</span>]+<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, ppa[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【修改指向NULL指针错误】*q &#x3D; *(p+5);</p>
<p>  q还没指向任何内存呢；</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>main() &#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;, *p = a + <span class="hljs-number">5</span>, *q = <span class="hljs-literal">NULL</span>;<br>    *q = *(p+<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, *p, *q);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【给函数传递数组指针】void f3(int(*p)[4]);  p是一个指向含4个int元素数组的指针；【分清楚数组名和数组名取地址】</p>
<p>  总结：</p>
<p>  <strong>① 数组名，是指向它的第一个一级成员的指针</strong></p>
<p>  <strong>② 数组名取地址，是指向整个数组的指针</strong></p>
<p>  再看二维数组b[3][4]，这个二维数组也可以可以看成一个含3个成员的一维数组，每一个成员含有4个int元素，依次，仿照一维数组的结论，有：</p>
<p>  （1）b[0]是个一维数组名，也是个地址，地址类型为：int *</p>
<p>  （2）&amp;b[0]是个地址，地址类型同：int (*p)[4]， 也即&amp;b[0]指向含4个int元素的一维数组</p>
<p>  更进一步：</p>
<p>  （3）b是个地址，地址类型同：int (*p)[4]，也即b指向含4个int元素的一维数组</p>
<p>  （4）&amp;b是个地址，地址类型同：int (*p)[3][4]，也即&amp;b指向含3x4个int元素的2维数组</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2013.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>字符串赋值操作：char s[5]&#x3D;{‘A’,‘B’,’C’,’D’,’E’}; (x)  —— 没有 ‘\0’ 不能算字符串；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2014.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li></li>
<li><p>内存问题：结构体包含数组该怎么判断大小？char name[7];   首先这个数组是元素 char 类型，可以分开填满int num; 之后的空间 所以依然保持4字节对齐而不是什么8字节甚至7字节，就是4字节对齐，就是4字节对齐，就是4字节对齐，就是4字节对齐，就是4字节对齐，就是4字节对齐，就是4字节对齐，就是4字节对齐，就是4字节对齐</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">7</span>];   <br>    <span class="hljs-type">short</span> age;<br>    <span class="hljs-type">char</span> sex;<br>&#125; student1;<br><span class="hljs-type">int</span> sz = <span class="hljs-keyword">sizeof</span>(student1);<br></code></pre></td></tr></table></figure>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2015.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2016.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>结构体套结构体怎么判断大小？【展开】【嵌套结构体的展开 再进行运算】</p>
</li>
</ul>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="C语言还是得去——"><a href="#C语言还是得去——" class="headerlink" title="C语言还是得去——&gt;"></a><a target="_blank" rel="noopener" href="https://www.notion.so/Linux-579789ac91ba4d9380e1b4e784cd0bbe?pvs=21">C语言还是得去——&gt;</a></h3><ul>
<li><p>C语言编译生成的程序有哪些部分？</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/STM32_HAL-2023-10-15-996797e72af14652b327f262d8b0ad9f?pvs=21">指路——&gt;</a></p>
<p>  【1008】<a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-STM32HAL-8-14-22d01922723e441a970d342ac41f20f9?pvs=21">指路2——&gt;</a></p>
</li>
<li><p>【容易忘 1004】指针常量和常量指针；</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">指路——&gt;</a></p>
</li>
<li><p>时间复杂度 O(N^(0.5))  使用等差数列反求</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2017.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2018.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>数组 *<em>int <em>p, a[7] &#x3D; {5,2,6,3,8,1};  p &#x3D; a+6; 得到的是a[7]的值，没有赋初值 默认为零；</em></em></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2019.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>函数指针typedef void (<em>fptr</em>)(int*)是正确的   void (<em>fptr)(int</em>)；定义也是正确的；</p>
<p>  但是 void (<em>fptr)(int</em>)； 就只是一个变量</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;   <span class="hljs-comment">/*声明一个函数*/</span><br><span class="hljs-built_in">int</span> (*p) (<span class="hljs-type">int</span> x);  <span class="hljs-comment">/*定义一个函数指针*/</span><br>p = Func;          <span class="hljs-comment">/*将Func函数的首地址赋给指针变量p*/</span><br></code></pre></td></tr></table></figure>
<p>  typedef void (<em>fptr)</em>(int*)是一个类型，可以去定义不同名字的函数指针变量</p>
<p>  p 是一个指向 参数为一个int 返回值为char 的函数的指针</p>
<p>  使用p 定义一个函数指针 pFun;</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">char</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;   <br>p pFun;   <br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">glFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123; <span class="hljs-keyword">return</span>;&#125;   <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>   </span><br><span class="hljs-function"></span>&#123;   <br>    pFun = glFun;   <br>    (*pFun)(<span class="hljs-number">2</span>);   <br>&#125;<br></code></pre></td></tr></table></figure>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2020.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>调用函数指针 直接用地址值调用函数    ((void (*)(int))0x20000000)()</p>
<p>  ((void (*)(int))0x20000000)()</p>
<p>  将 0x20000000 转换为 函数指针并调用，使用 name +（）调用</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2021.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>变量声明在main 外部， main内部也声明一个同名变量，并赋值为同名变量值；得到的结果是错误的，这个 _outside_main  变量是未定义值 所以返回乱码</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2022.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2023.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>volatile 访问硬件寄存器也会用到</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2024.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>a-&gt;next 和 (*a).next 等价 √</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abap">ListNode a_node;<br>    ListNode *b_node = &amp;a_node;<br>    b_node-&gt;next = b_node;<br>    ( *b_node ).next = b_node;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【0916】 优先级！！！  “.”的优先级大于 “*”;  所以在使用结构体指针时应该注意 (*p).val; 才是正确的；或者 p-&gt;val;</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2025.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>C语言的函数能不能单独进行编译？——可以。dll就是</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2026.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>C语言 union内存是由其占用内存最大的变量来决定</p>
<h1 id="联合体union内存分配详解-听风不是云的博客-CSDN博客"><a href="#联合体union内存分配详解-听风不是云的博客-CSDN博客" class="headerlink" title="联合体union内存分配详解_听风不是云的博客-CSDN博客"></a><strong>联合体union内存分配详解_听风不是云的博客-CSDN博客</strong></h1><p>  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44986938/article/details/109548004">blog.csdn.net**&#x2F;qq_44986938&#x2F;article&#x2F;details&#x2F;109548004</a></p>
<p>  <a target="_blank" rel="noopener" href="https://g.csdnimg.cn/static/logo/favicon32.ico">https://g.csdnimg.cn/static/logo/favicon32.ico</a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44986938/category_10018574.html">笔记 专栏收录该内容</a><br>  16 篇文章 0 订阅订阅专栏<br>  1.概述<br>  联合体<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=union&spm=1001.2101.3001.7020">union</a>的定义方式与结构体一样，但是二者有根本区别。<br>  在结构中各成员有各自的内存空间，一个结构变量的总长度是各成员长度之和。而在“联合”中，各成员共享一段内存空间，一个联合变量的长度等于各成员中最长的长度。<br>  2.联合体长度</p>
<p>  &#96;在The C Programming Language里面讲述union内存分配的原话是</p>
<p>  1）联合体就是一个结构</p>
<p>  2）联合体的所有成员相对于基地址的偏移量为0</p>
<p>  3）此结构空间要大到总够容纳最“宽”的成员</p>
<p>  4）并且，其对其方式要适合于联合体中所有类型的成员&#96;</p>
<p>  我的理解可以概括为两点：<br>  1）联合体的结构空间要足够大，要等于最长的一个结构变量的空间，但是这个最长的空间要满足以下条件：</p>
<p>   &#96;1.要大于等于最长的一个结构变量的空间</p>
<pre><code class="hljs">2.并且要能够整除其他结构变量的数据长度，即联合体空间对其他成员的元类型要能够整除（int a[5]，其元类型为int，元类型长度为4），实际上就是要取一个元类型的最小公倍数。
</code></pre>
<p>  • 1<br>  • 2<br>  • 3&#96;<br>  这儿举例来说</p>
<p>  &#96;union<br>  {<br>  float   fuel_load;<br>  char a[5];<br>  int   pallets;<br>  }fighter; </p>
<p>  • 1<br>  • 2<br>  • 3<br>  • 4<br>  • 5<br>  • 6&#96;<br>  这个结构体中，各个结构变量的空间分别为float fuel_load; 占4个字节，char a[5];占5个字节，int pallets;占4个字节。通过“3）此结构空间要大到总够容纳最“宽”的成员”这句话，我们可以认为是结构体的空间为5个字节即可，但是“其对其方式要适合于联合体中所有类型的成员”没有满足，对于这个问题，通过上面红色字体部分可以解决。，因此联合体空间为88可以整除 4（float、int长度）和1（char的长度），并且8大于数组5.<br>  再举一个例子有助于大家理解。</p>
<p>  &#96;struct   aircraft<br>  {<br>  int   wingspan;<br>  int   passengers;<br>  union<br>  {<br>  float   fuel_load;<br>  float   bomb_load;<br>  int   pallets;<br>  };<br>  }fighter; </p>
<p>  • 1<br>  • 2<br>  • 3<br>  • 4<br>  • 5<br>  • 6<br>  • 7<br>  • 8<br>  • 9<br>  • 10<br>  • 11&#96;<br>  sizeof（fighter） 是12 。int wingspan; int passengers;两个int型 8个字节。union中 3个都是4个字节，因此union长度为4个字节。<br>  3.内存分配<br>  一句话：联合体变量的各个成员都是从低字节开始公用的。即：所有的成员都是从低字节开始的。<br>  我们先为整个union分配一个空间，这个空间大小就是上面（2）内存分配中所讲述的。</p>
<p>  &#96;union {<br>    int i;<br>    char x[2];<br>  }a;<br>  int main(void)<br>  {<br> a.x[0] &#x3D; 10;<br> a.x[1] &#x3D; 1;<br> printf(“%d\n”,a.i);<br> return 0;<br>  }</p>
<p>  • 1<br>  • 2<br>  • 3<br>  • 4<br>  • 5<br>  • 6<br>  • 7<br>  • 8<br>  • 9<br>  • 10<br>  • 11&#96;<br>  其内存如下图所示。a.x[0] 处于低字节，x[1]高字节。当调用i这个成员变量的时候，其开始地址仍然是从起始地址开始，数4个字节输出。因此为 256 + 10 &#x3D; 266<br>  程序：</p>
<p>  &#96;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#if 0<br>  typedef union data{<br>   float a;<br>   float b;<br>   int c;<br>  }data_t;<br>  int main(int argc ,char **argv)<br>  {</p>
<pre><code class="hljs">   printf(&quot;sizeof(float):%d\nsizeof(data_t):%d\n&quot;,sizeof(float),sizeof(data_t));
   return 0;
</code></pre>
<p>  }<br>  #endiftypedef union data{<br>   int i;<br>   char x[2];<br>  }data_t;<br>  int main(int argc ,char **argv)<br>  {</p>
<pre><code class="hljs">      data_t datab;
   memset(&amp;datab,0,sizeof(datab));
   datab.x[0] = 10;
   datab.x[1] = 1;
  
      printf(&quot;sizeof(float):%d\nsizeof(int):%d\n&quot;,sizeof(float),sizeof(int));
   printf(&quot;datab.i :%d\n&quot;,datab.i);
   return 0;
</code></pre>
<p>  }&#96;</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/yankai0219/article/details/6892189">原文链接</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yankai0219/article/details/6892189">https://blog.csdn.net/yankai0219/article/details/6892189</a><br>  显示推荐内容 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44986938">听风不是云</a>关注专栏目录</p>
<p><img src="https://img-blog.csdnimg.cn/20201014180756913.png?x-oss-process=image/resize,m_fixed,h_64,w_64" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20201014180756913.png?x-oss-process=image/resize,m_fixed,h_64,w_64"></p>
<p><img src="https://img-blog.csdnimg.cn/20201107155006691.gif#pic_center" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20201107155006691.gif#pic_center"></p>
<p><a target="_blank" rel="noopener" href="https://profile-avatar.csdnimg.cn/13bbd358c58b4c12be411a6deaee23ac_qq_44986938.jpg!1">https://profile-avatar.csdnimg.cn/13bbd358c58b4c12be411a6deaee23ac_qq_44986938.jpg!1</a></p>
</li>
<li><p>X&gt;Y&gt;Z ? 结果是什么 ——&gt; 计算规则 (X&gt;Y)&gt;Z  首先由(X&gt;Y)得到布尔值 true &#x2F; false 代表1&#x2F;0； 再拿1&#x2F;0去和Z比较</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2027.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>使用static修饰的变量能在外部用extern修饰然后调用吗？—— 不能，会找不到定义；</p>
<p>  static和extern是两个用于修饰变量和函数的关键字，它们可以影响变量和函数的生命周期和作用域¹。生命周期是指变量或函数在内存中存在的时间，作用域是指变量或函数可以被访问的范围²。</p>
<p>  如果一个变量或函数被static修饰，那么它的生命周期是静态的，也就是说它在程序开始时就分配内存，直到程序结束时才释放内存¹。它的作用域是内部的，也就是说它只能在定义它的文件中被访问，不能被其他文件访问¹。</p>
<p>  如果一个变量或函数被extern修饰，那么它的生命周期也是静态的，但是它的作用域是外部的，也就是说它可以被定义它的文件以及其他文件访问，只要在其他文件中用extern声明它即可¹。</p>
<p>  所以，如果一个变量被static修饰，那么它不能用extern在外部文件中调用，因为static限制了它的作用域³。例如：</p>
<p>  &#x2F;&#x2F; file1.c<br>  static int a &#x3D; 10; &#x2F;&#x2F; a 是内部变量</p>
<p>  &#x2F;&#x2F; file2.c<br>  #include &lt;stdio.h&gt;<br>  extern int a; &#x2F;&#x2F; 声明 a 是外部变量<br>  int main(void) {<br>  printf(“%d\n”, a); &#x2F;&#x2F; 试图访问 a<br>  return 0;<br>  }</p>
<p>  这个程序在编译时会报错，因为file2.c找不到a的定义³。</p>
<p>  希望我的回答对您有帮助。如果您还有其他问题，欢迎继续提问。😊</p>
</li>
<li><p>volatile 能和 const 一起修饰一个变量吗？——可以：</p>
<p>  volatile表示不要优化这个变量每次都到内存中读取值，const表示这个变量不可被修改；</p>
<p>  这两个Feature不冲突，比如在访问寄存器时就这样修饰；</p>
<p>  一个参数既可以是 const 还可以是 volatile 吗？解释为什么。</p>
<p>  答: 是的。</p>
<p>  例如是只读的状态寄存器。</p>
<p>  volatile 是不让编译器去优化它。const 是不让程序去修改它。</p>
</li>
<li><p>使用volatile的场景以及如何避免<a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219.md">临界资源</a>访问冲突的问题：</p>
<p>  中断使用到的全局变量；多任务修改的全局变量；寄存器访问；</p>
<p>  volatile 用在如下的几个地方：<br>  1）、中断服务程序中修改的供其它程序检测的变量需要加volatile；<br>  2）、多任务环境下各任务间共享的标志应该加volatile；<br>  3）、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</p>
<p>  以上几种情况还要同时考虑数据的完整性（比如标志读了一半被打断了重写），volatile 是不具备原子性的，所以要考虑临界资源的访问冲突问题。</p>
<p>  1）中可以通过关中断来实现，或其他方法实现；<br>  2）中可以禁止任务调度，或其他方法实现；<br>  3）中则只能依靠硬件的良好设计了。</p>
</li>
<li><p>堆栈 具体解析：栈是编译时由编译器决定大小，堆是动态分配的；</p>
<p>  首先堆（heap）和栈（stack）两个重名不是翻译问题，而是英文原文就是一样的。</p>
<p>  数据结构中堆是满足父子节点大小（比如大根堆中规定父节点的值要比子节点大）关系的一种完全二叉树。由于是完全二叉树，可以用数组来实现，用节点编号来访问和操作节点，简化程序，提升效率。而其大小关系则为我们查询堆中极值提供了常数级别的时间复杂度，又由二叉树的性质，插入和删除则为对数级别时间复杂度。这就好像地位不同的人在排队，排在最前面的一定是地位最高的人，所以堆是优先队列（Priority Queue）实现的基础。利用这一特性，可以加速某些需要频繁取队列中极值的算法比如 A* 算法等。</p>
<p>  数据结构中的栈则是一种相当简单的结构。就像是只有一个口的深深的文件桶，先进去的文件会被压在下面（push），而且我们每次只能取到最上面的文件（pop），体现了其先进后出（FILO）的特性。虽然栈操作简单，但也有如单调栈等在栈内保持一定数据特性的变种。</p>
<p>  操作系统中的堆和栈都是指内存空间，不同的是堆为按需申请、动态分配，例如 C 中的 malloc 函数和 C++ 中的 new 操作（当然 C++ 的 new 不仅仅是申请内存这么简单）。内存中的空闲空间并不是连续的，而是不同程序占用了不同的一块一块的内存，即使是同一个程序也可能占用了不同地方的多块内存。操作系统中则会对这些空间进行统一的管理，在应用程序提出申请时，就会从堆中按照一定算法找出一块可用内存，标记占用空间等信息之后返回其起始地址给程序。在程序结束之前，操作系统不会删除已经申请的内存，而是要靠程序主动提出释放的请求（free、delete），如果使用后忘记释放，就会造成所谓的内存泄漏问题。因此堆基本上可以理解为当前可以使用的空闲内存，但是其申请和释放都要程序员自己写代码管理。</p>
<p>  而操作系统的栈则是程序运行时自动拥有的一小块内存，大小在编译期时由编译器参数决定，用于局部变量的存放或者函数调用栈的保存。在 C 中如果声明一个局部变量（例如 int a），它存放的地方就在栈中，而当这个局部变量离开其作用域之后，所占用的内存则会被自动释放，因此在 C 中局部变量也叫自动变量。栈的另一个作用则是保存函数调用栈，这时和数据结构的栈就有关系了。在函数调用过程中，常常会多层甚至递归调用。每一个函数调用都有各自的局部变量值和返回值，每一次函数调用其实是先将当前函数的状态压栈，然后在栈顶开辟新空间用于保存新的函数状态，接下来才是函数执行。当函数执行完毕之后，栈先进后出的特性使得后调用的函数先返回，这样可以保证返回值的有序传递，也保证函数现场可以按顺序恢复。操作系统的栈在内存中高地址向低地址增长，也即低地址为栈顶，高地址为栈底。这就导致了栈的空间有限制，一旦局部变量申请过多（例如开个超大数组），或者函数调用太深（例如递归太多次），那么就会导致栈溢出（Stack Overflow），操作系统这时候就会直接把你的程序杀掉。</p>
</li>
<li><p>return ((*ptr) * (*ptr));  不能用这种语句；应该是使用指针读取一次变量到temp然后就进行计算；</p>
<p>  下面的函数被用来计算某个整数的平方，它能实现预期设计目标吗？如果不能，试回答存在什么问题：<br>  int square(volatile int *ptr)<br>  {<br>  return ((*ptr) * (<em>ptr));<br>  }<br>  答: 不能。该代码本意是返回 ptr 指向的值的平方，但</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p>
<p>  int square(volatile int* &amp;ptr) &#x2F;&#x2F;这里参数应该申明为引用，不然函数体里只会使用副本，外部没法更改<br>  {<br>  int a &#x3D; *ptr;<br>  int b &#x3D; ptr;<br>  return ab;<br>  }<br>  <strong>由于*ptr的值可能在两次取值语句之间发生改变，因此a和b可能是不同的。</strong>结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：</p>
<p>  int square(volatile int*ptr)<br>  {<br>  int a &#x3D; <em>ptr;<br>  return a</em>a;<br>  }</p>
</li>
<li><p>野指针是什么？怎么规避野指针？</p>
<p>  答：野指针就是 指针指向的位置是不可知的。</p>
<p>  原因：</p>
<p>  1、指针变量未初始化</p>
<p>  2、指针释放后之后未置空（指针所指向的变量 在指针之前被销毁）</p>
<p>  3、指针操作超越变量作用域</p>
<p>  规避：</p>
<p>  1、初始化时置 NULL</p>
<p>  2、释放时置 NULL</p>
</li>
<li><p>【非常重要】数组和指针的区别！</p>
<h3 id="4-简述数组与指针的区别？"><a href="#4-简述数组与指针的区别？" class="headerlink" title="4.简述数组与指针的区别？"></a><strong>4.简述数组与指针的区别？</strong></h3><p>  答：</p>
<p>  数组 在静态存储区被创建（如全局数组），或 在栈上被创建。</p>
<p>  指针 可以随时指向任意类型的内存块。</p>
<p>  (1)修改内容上的差别</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> a[] = “hello”;<br>a[<span class="hljs-number">0</span>] = ‘X’;<br><span class="hljs-type">char</span> *p = “world”;<span class="hljs-comment">// 注意p 指向常量字符串</span><br>p[<span class="hljs-number">0</span>] = ‘X’;<span class="hljs-comment">// 编译器不能发现该错误，运行时错误1234</span><br></code></pre></td></tr></table></figure>
<p>  (2) sizeof(数组名),计算出数组的容量（字节数）；</p>
<p>  sizeof(指针变量),计算出指针变量的字节数，而不是所指的内存容量。</p>
</li>
<li><p>C语言编译后生成代码各个段的详细分析：</p>
<p>  <a target="_blank" rel="noopener" href="https://hjk.life/posts/segment-ram/#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">https://hjk.life/posts/segment-ram/#静态变量</a></p>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%20444021d5aebb416bb8a18fa9fed369c4.md"><strong>一文看懂内存分段</strong></a></p>
<p>  文章摘录和总结如下：</p>
<ul>
<li><p>text、data都会保存在可执行文件或说固件中；BSS段不在编译生成的可执行文件中；BSS是未初始化的全局变量，只需要在text段中做标记即可；如此可减少可执行文件的大小；</p>
</li>
<li><p>BSS段在启动时默认清零；然后会被全部加载到RAM中；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2028.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2029.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2030.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>关于text段：得益于<code>XIP 就地执行</code>技术，CPU 可以直接从 ROM 中读取指令，而无需将 text 段拷贝入内存；<code>XIP 就地执行</code>技术核心是将 ROM 空间映射到 CPU 总线，<strong>能让 CPU 和访问 RAM 一样直接使用总线地址访问 ROM</strong></p>
</li>
</ul>
</li>
<li><p>char b[ 0 ];  sizeof( b );  的结果是什么？ —— 0</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2031.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>const char *  不能转换为 char const *; ！！！！！常量指针不能转换为指针常量；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2032.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0914 麦格米特】数组变量arr;  &amp;arr + 1 与 arr+1 的区别：&amp;arr + 1 是加上整个数组的大小，指向了数组外，也就是最后一个元素的下一个内存块；需要强制转换才能得到指定值；</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">int arr_2[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-title function_">printf</span>( <span class="hljs-string">&quot;&amp;arr_2 + 1  -&gt;  %d\n&quot;</span>, *( (int*)( &amp;arr_2 + <span class="hljs-number">1</span> ) - <span class="hljs-number">1</span> ) );           <span class="hljs-comment">// ! 如果是获取 &amp;arr 则一定要强制类型转换</span><br>    <span class="hljs-title function_">printf</span>( <span class="hljs-string">&quot;( arr_2 + 1 ) -&gt; %d\n&quot;</span>, *( arr_2 + <span class="hljs-number">1</span> ) );<br></code></pre></td></tr></table></figure>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2033.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0914 麦格米特】浮点数！！！ ( 1 &#x2F; 3) &#x3D;0;  ( 1.0 &#x2F; 3  )  &#x3D; 0.3333;  一定要注意计算浮点数一定要有一个数是浮点类型，否则直接为0；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2034.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> <span class="hljs-title function_">select_3</span>(<span class="hljs-params"> <span class="hljs-keyword">void</span> </span>)<br>&#123;<br>    float sum = <span class="hljs-number">0.0</span>, sum2;<br>    sum = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>/<span class="hljs-number">2</span> + (float) ( <span class="hljs-number">1</span> / <span class="hljs-number">3</span>);<br>    sum2 = <span class="hljs-number">1</span> + <span class="hljs-number">1.0</span>/<span class="hljs-number">2</span> + (float) ( <span class="hljs-number">1.0</span> / <span class="hljs-number">3</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;sum = 1 + 1/2 + (float) ( 1 / 3);-&gt;&quot;</span> &lt;&lt; sum &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sum2 = 1 + 1.0/2 + (float) ( 1.0 / 3);-&gt;&quot;</span> &lt;&lt; sum2 &lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【0915 创维】int i &#x3D; 0; <strong>printf</strong>(“%d,%d,%d\n”, i++, i++, i++); 输出什么？为什么？——&gt; 2,1,0</p>
<p>  因为函数参数用栈传输，LIFO 后进先出，所以最后一个 i++ 先进入；最后输出210</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2035.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0915 创维】<strong>printf</strong>( “%p\n”, <strong>main</strong> ); ——&gt; 输出main函数的地址；</p>
</li>
<li><p>【0915 创维】long long 是八个字节：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2036.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0915 创维】静态变量一开始就会被初始化为0, 包括全局变量 局部静态变量；而局部变量是保存在堆栈当中的，不运行就不知道它的地址，所以不会初始化为0；</p>
<h2 id="程序的存储空间布局"><a href="#程序的存储空间布局" class="headerlink" title="程序的存储空间布局"></a>程序的存储空间布局</h2><p>  C程序主要由以下几部分组成：</p>
<ul>
<li>正文段。即机器指令部分，为防止意外被修改，设为只读。</li>
<li>初始化数据段。它包含了程序中需要明确赋初值的静态变量。</li>
<li>未初始化数据段。它包含了程序中未赋初值的或初始化为0的静态变量，在程序开始执行之前，内核将此段中的数据初始化为0。</li>
<li>栈。它保存了自动（局部）变量以及函数调用所要的信息。</li>
<li>堆。用于动态内存分配。例如使用malloc函数进行内存分配。</li>
</ul>
<p>  其中，正文段和数据段的内容是“静态”的，因为在程序被编译出来之后，在整个程序地址就确定了，而堆栈中的内容是”动态”变化的，它随着进行的运行而不断变化着，再加上栈随机化的策略，使得程序每次运行时，栈的地址也是不确定的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  我们来总结一下本文的主要内容：</p>
<ul>
<li>如果变量是静态的，它会被初始化为0；如果变量是自动的，它不会被初始化。</li>
<li>静态的变量包括全局变量、静态全局变量、静态局部变量。</li>
<li>使用局部变量之前对其进行初始化，避免使用“脏值”。</li>
<li>从可读性考虑，静态变量也建议显示初始化。</li>
<li>初始化为0的静态变量仍然存在未初始化数据段中（BSS段）。</li>
</ul>
</li>
<li><p>【0915 创维 补充】就算是全局变量也保存在内存；如下图，虽然说是保存在静态区，但是静态区也是在内存中，和堆栈是一块的；静态区并不在Flash中，Flash最原始的是只读存储器，ROM；虽然有XIP，但是也只是能让CPU从Flash中读取代码运行而不是读数据；</p>
<p>  <strong>静态存储区在程序编译后地址就确定了！！！！</strong></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2037.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2038.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0915 创维】链接两个动态库时，两个动态库包含同名函数，能编译通过吗？——&gt;能；分清楚是动态库dll，不是目标文件.o的链接，.o是肯定不能出现同名函数的，但是动态库可以；</p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352668522">https://zhuanlan.zhihu.com/p/352668522</a></p>
<h3 id="测试3：动态库"><a href="#测试3：动态库" class="headerlink" title="测试3：动态库"></a><strong>测试3：动态库</strong></h3><p>  使用如下命令行编译动态库<code>libtest1.so</code>和<code>libtest2.so</code>并编译可执行文件。</p>
<p>  <code>gcc -shared -fPIC -o libtest1.so test1.c   gcc -shared -fPIC -o libtest2.so test2.c   gcc -L. ./main.c -ltest1 -ltest2 -o main</code></p>
<p>  编译无报错，ldd检查，<code>libtest1.so</code>和<code>libtest2.so</code>确实都链接进main可执行文件中。执行结果如下：</p>
<p>  <code>$ LD_LIBRARY_PATH**=**. ./main   call from test1.c</code></p>
<p>  可见，在动态链接时，不同的链接库可以有同名函数，不影响编译。这是由动态链接库的性质决定的，其只有在运行时才会按需动态加载，并且加载的顺序是由编译时链接的顺序决定的。这也就说符号会以第一个查找到的为准（<code>Symbols are resolved on a first match basis</code>）。</p>
<p>  我们也可以通过设置<code>LD_PRELOAD</code>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick">提前将某动态库load进内存</a>。</p>
</li>
<li><p>【0915 创维】a &#x3D; a * a &lt;&lt; 1; 乘法 和 位移 哪个优先级高 → 乘法：</p>
</li>
<li><p>【0915 牛客】a &#x3D; a++ &#x3D; 5; 错在哪里？——&gt; a++返回的是一个临时变量，不能对其赋值；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2039.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0916】将一位置1；将一位置0；代码 #define BIT3 (0x1&lt;&lt;3) ;   与BIT3做 |&#x3D; 得到置位；  与BIT3的取反 ~BIT3 做 &amp;&#x3D;  置0；</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">#define <span class="hljs-title class_">BIT3</span> (<span class="hljs-number">0x1</span>&lt;&lt;<span class="hljs-number">3</span>) <br><span class="hljs-keyword">static</span> int a; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">set_bit3</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) <br>&#123; <br>a |= <span class="hljs-title class_">BIT3</span>; <br>&#125; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear_bit3</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) <br>&#123; <br>a &amp;= ~<span class="hljs-title class_">BIT3</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【0905】一段读取输入的每行数据中数字的代码【没明白】</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld:%lld,&quot;</span>,&amp;a, &amp;b) != EOF) &#123;<br>    arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(a, b));<br>    n++;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【0916】指针数组数组指针 函数指针的样子；一定要常看；特别  *<em>int (<em>a[10])(int); a是一个数组；数组元素是函数指针，函数指针指向一个返回值为int，参数为int 的函数；</em></em></p>
<p>  a) 一个整型数（An integer）<br>  b) 一个指向整型数的指针（A pointer to an integer）<br>  c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）<br>  d) 一个有10个整型数的数组（An array of 10 integers）<br>  e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>  f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>  g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）<br>  h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）</p>
<p>  答案是：<br>  a) int a; &#x2F;&#x2F; An integer<br>  b) int *a; &#x2F;&#x2F; A pointer to an integer<br>  c) int **a; &#x2F;&#x2F; A pointer to a pointer to an integer<br>  d) int a[10]; &#x2F;&#x2F; An array of 10 integers<br>  e) int *a[10]; &#x2F;&#x2F; An array of 10 pointers to integers<br>  f) int (*a)[10]; &#x2F;&#x2F; A pointer to an array of 10 integers<br>  g) int (*a)(int); &#x2F;&#x2F; A pointer to a function a that takes an integer argument and returns an integer<br>  h) int (*a[10])(int); &#x2F;&#x2F; An array of 10 pointers to functions that take an integer argument and return an integer</p>
</li>
<li><p>【0919】二维数组一定要用 一维数组包一维数组的思想进行思考！！！</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ErWeriShuzu</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a[0]\t-&gt;&quot;</span> &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&amp;a[0][0]\t-&gt;&quot;</span> &lt;&lt; &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&amp;a[0][1]\t-&gt;&quot;</span> &lt;&lt; &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a[0]+1\t-&gt;&quot;</span> &lt;&lt; a[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-comment">// * 二维数组相当于 一维数组包含一维数组 内外两层</span><br>    <span class="hljs-comment">// * 所以 a[0] 表示一个数组， a[0] + 1 就还是指针 指向第一个数组的第一个元素</span><br>    <span class="hljs-comment">// * a + 1 也是数组指针 外层一维数组 的 第二个元素的地址 也就是二维数组的第二行第一个元素</span><br>    <span class="hljs-comment">// ! 一定要记得 是一个数组包数组 </span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;&amp;a[1][0]\t-&gt;&quot;</span> &lt;&lt; &amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a+1\t-&gt;&quot;</span> &lt;&lt; a + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【0919】volatile操作不具备原子性，需要手动屏蔽中断、手动禁止任务调度：</p>
<h3 id="3-一个指针可以是-volatile-吗？解释为什么。"><a href="#3-一个指针可以是-volatile-吗？解释为什么。" class="headerlink" title="3.一个指针可以是 volatile 吗？解释为什么。"></a><strong>3.一个指针可以是 volatile 吗？解释为什么。</strong></h3><p>  答: 是的。例如当一个中断服务子程序修改一个指向一个buffer的指针时。</p>
<h3 id="4-volatile-用在如下的几个地方："><a href="#4-volatile-用在如下的几个地方：" class="headerlink" title="4.volatile 用在如下的几个地方："></a><strong>4.volatile 用在如下的几个地方：</strong></h3><p>  1）、中断服务程序中<strong>修改的</strong>供其它程序<strong>检测的</strong>变量需要加volatile；</p>
<p>  2）、多任务环境下各任务间共享的标志应该加volatile；</p>
<p>  3）、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</p>
<h3 id="5-以上几种情况还要同时考虑数据的完整性（比如标志读了一半被打断了重写），volatile-是不具备原子性的，所以要考虑临界资源的访问冲突问题。"><a href="#5-以上几种情况还要同时考虑数据的完整性（比如标志读了一半被打断了重写），volatile-是不具备原子性的，所以要考虑临界资源的访问冲突问题。" class="headerlink" title="5.以上几种情况还要同时考虑数据的完整性（比如标志读了一半被打断了重写），volatile 是不具备原子性的，所以要考虑临界资源的访问冲突问题。"></a><strong>5.以上几种情况还要同时考虑数据的完整性（比如标志读了一半被打断了重写），volatile 是不具备原子性的，所以要考虑临界资源的访问冲突问题。</strong></h3><p>  1）中可以通过关中断来实现，或其他方法实现；</p>
<p>  2）中可以禁止任务调度，或其他方法实现；</p>
<p>  3）中则只能依靠硬件的良好设计了。</p>
</li>
<li><p>【0926】memcpy和strcpy的区别是哪些？</p>
<p>  memcpy和strcpy的区别是哪些？</p>
<p>  memcpy和strcpy都是标准C库函数，用于复制内存或字符串的内容。它们主要有以下三方面的区别：</p>
<ul>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/447201383">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38169413/article/details/88380877">2</a></li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符’\0’才结束，所以容易溢出。memcpy则是根据其第三个参数决定复制的长度。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/447201383">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38169413/article/details/88380877">2</a></li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/447201383">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38169413/article/details/88380877">2</a></li>
</ul>
<p>  如果你想了解更多关于memcpy和strcpy的知识，你可以参考以下链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/447201383">深入了解strcpy和memcpy的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38169413/article/details/88380877">strcpy和memcpy的区别</a></li>
</ul>
</li>
<li><p>【1006】C语言类型隐式转换、算数转换、操作符优先级；*p++ ——&gt; 先自增 再取值；截断问题；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2040.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  运算符转换等级：int是最低等级，会被转换为其他类型；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2041.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<ul>
<li><p>截断问题：255_uchar + 256_uchar &#x3D; 254_uchar</p>
<p>  <strong>注意：</strong></p>
<p>  但是算术转换要合理，要不然会有一些潜在的问题</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> num = f;<span class="hljs-comment">//隐式转换，会有精度丢失</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a><strong>2.例题</strong></h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> a = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b = <span class="hljs-number">255</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = <span class="hljs-number">255</span>;<br>	a = b + c;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>  输出结果：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2042.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  分析：</p>
<p>  <img src="https://img-blog.csdnimg.cn/a3c1bfd93274455f9cb66a05ba476770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5MjE3Mjk3,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/a3c1bfd93274455f9cb66a05ba476770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5MjE3Mjk3,size_16,color_FFFFFF,t_70"></p>
<p>  b和c的值被提升为普通整型，然后再执行加法运算。</p>
<p>  加法运算完成之后，结果将被截断，然后再存储于a中。</p>
<p>  <strong>注意：</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,a);</span><br><span class="hljs-string">int b = a;</span><br><span class="hljs-string">123</span><br></code></pre></td></tr></table></figure>
<p>  这也是函数，传参就要发生值拷贝，就要用到CPU，也同样要发生隐式转换。</p>
</li>
</ul>
<h3 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级!!!"></a>操作符优先级!!!</h3><p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2043.png" srcset="/img/loading.gif" lazyload alt="Untitled">
  </p>
</li>
<li><p>[? 1007 实际上ARM使用的是17个寄存器 R0~R15 + PSR 程序状态寄存器]</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2044.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【补充】结构体对齐的规则：变量对齐，自身对齐(最大的整数倍)；</p>
<p>  【简单来说 结构体自身对齐值 就是取结构体成员中占用内存最大的一个作为对齐值 比如文章中第二个结构体 uint64_t 之后的 uint8_t 实际上占了8字节，<strong>而且最后结构体的大小要是最大成员字节数的整数倍！】</strong></p>
<p>  二、结构体成员对齐问题：</p>
<p>  首先明白一点，结构体里面的变量是什么类型，此变量的位置就是至少要几字节对齐，所以就存在结构体实际占用大小不是这些变量之和。</p>
<p>  typedef struct<br>  {<br>  uint8_t a;<br>  uint16_t b;<br>  uint32_t c;<br>  uint64_t d;</p>
<p>  }info;</p>
<p>  这种定义，info占用了16字节，a单字节对齐，b是两字节对齐，而c要是4字节对齐，从出现b定义完毕后空出来1个字节未被使用。d是8字节对齐，这样就是16字节。而我们切换下变量定义顺序：<br>  typedef struct<br>  {<br>  uint16_t b;<br>  uint32_t c;<br>  uint64_t d;</p>
<p>  uint8_t  a;<br>  }info;</p>
<p>  这种定义就要占用24字节，b占用2字节对齐，c需要4字节对齐，这样就空出来2两个字节未使用，d占用8字节，最后一个a占用了8字节。</p>
<p>  如果想定义几个变量就几个字节，变量前面加前缀__packed即可。</p>
<p>  不管是上面那种定义方式，都是占用15个字节。</p>
<p>  __packed typedef struct<br>  {<br>  uint8_t a;   1个<br>  uint16_t b; 2个<br>  uint32_t c; 4个<br>  uint64_t d; 8个</p>
<p>  }info; 作者：armfly <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv13900654?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv13900654?spm_id_from&#x3D;333.999.0.0</a> 出处：bilibili</p>
<p>  自身对齐值：数据类型本身的对齐值，例如char类型的自身对齐值是1，short类型是2，int类型是4；</p>
<p>  指定对齐值：编译器或程序员指定的对齐值，32位单片机的指定对齐值默认是4；</p>
<p>  有效对齐值：自身对齐值和指定对齐值中较小的那个。</p>
<p>  对齐有两个规则：</p>
<p>  <strong>1、不但结构体的成员有有效对齐值，结构体本身也有对齐值。这主要是考虑结构体的数组，对于结构体或者类，要将其补齐为其有效对齐值的整数倍。而结构体的有效对齐值是其最大数据成员的自身对齐值整数倍；</strong></p>
<p>  2、存放成员的起始地址必须是该成员有效对齐值的整数倍。其他自动填补。</p>
</li>
<li><p>【1007】非常重要的 内存字节对齐！！全局变量对齐，局部变量对齐，结构体对齐：</p>
<ul>
<li><p>首先是内存对齐的概念：存储数据的位置要从指定的内存地址开始；</p>
<p>  一、引出问题：</p>
<p>  字节对齐的含义：4字节对齐的含义就是变量地址对4求余数为0； 8字节对齐就是地址对8求余等于0，依次类推：</p>
<p>  比如<br>  uint32_t *p;<br>  p&#x3D;(uint32_t *)0x20000004; 这个地址是4字节对齐。</p>
<p>  如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。</p>
<p>  转换为二进制表示</p>
</li>
<li><p>背景：M0&#x2F;M0+&#x2F;M1芯片是不支持非对齐访问，会直接报错HardFault；但是M3M4M7可以但是依然会出现很多问题：</p>
<p>  对于M3和M4而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间),  因为M3和M4是支持的，而M0&#x2F;M0+&#x2F;M1是不支持的，不支持内核芯片，只要非对齐访问就会触发硬件异常。</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2045.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  M7内核也支持非对齐访问，在M7的TRM中描述如下：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2046.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>全局变量对齐：根据数据类型大小对齐：</p>
<p>  基本上用户定义的变量是几个字节就是几字节对齐，这个比较好理解。</p>
<p>  uint8_t定义变量地址要1字节对齐。<br>  uint16_t定义变量地址要2字节对齐。<br>  uint32_t定义变量地址要4字节对齐。<br>  uint64_t定义变量地址要8字节对齐。</p>
</li>
<li><p>结构体成员对齐问题：不仅要注意内部，还要注意结构体本身的对齐：</p>
<p>  首先明白一点，结构体里面的变量是什么类型，此变量的位置就是至少要几字节对齐，所以就存在结构体实际占用大小不是这些变量之和。</p>
<p>  typedef struct<br>  {<br>          uint8_t a;<br>          uint16_t b;<br>          uint32_t c;<br>          uint64_t d;        <br>  }info;</p>
<p>  这种定义，info占用了16字节，a单字节对齐，b是两字节对齐，而c要是4字节对齐，从出现b定义完毕后空出来1个字节未被使用。d是8字节对齐，这样就是16字节。而我们切换下变量定义顺序：<br>  typedef struct<br>  {<br>          uint16_t b;<br>          uint32_t c;<br>          uint64_t d;        <br>          uint8_t  a;<br>  }info;</p>
<p>  这种定义就要占用24字节，b占用2字节对齐，c需要4字节对齐，这样就空出来2两个字节未使用，d占用8字节，最后一个a占用了8字节。</p>
<p>  如果想定义几个变量就几个字节，变量前面加前缀__packed即可。</p>
<p>  不管是上面那种定义方式，都是占用15个字节。</p>
<p>  __packed typedef struct<br>  {<br>          uint8_t a;   1个<br>          uint16_t b; 2个<br>          uint32_t c; 4个<br>          uint64_t d; 8个        <br>  }info; 作者：硬汉嵌入式 <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv13900654/?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv13900654/?spm_id_from&#x3D;333.999.0.0</a> 出处：bilibili</p>
</li>
<li><p>【困难】局部变量对齐问题：牵扯到AAPCS，也就是ARM内核调用函数的规则；</p>
<p>  AAPCS规定栈任何时候都要4字节对齐，在调用入口必须8字节对齐；</p>
<p>  SP最后两位硬件规定为0，不能改变；</p>
<p>  8字节对齐可以不遵守，但是可能会出现一些问题；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2047.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  对于汇编的8字节对齐 需要手动写Preserve8，C语言函数编译器会自己加：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2048.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  强制使函数为4字节，printf会输出错误值：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2049.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2050.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>中断字节对齐：M3M4可以是4或8字节对齐；但是最好是8字节对齐，如果发现SP的地址在4字节对齐，硬件会自动对齐到8字节；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2051.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>RTOS任务栈对齐：8字节，否则某些函数会输出错误值，和函数局部变量对齐一样；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2052.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2053.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>【1008】引起HardFault的原因分析</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2054.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1009】C语言函数不规定返回值时默认为int：</p>
<p>  如图 实际上已经找不到这个函数，但是还是默认有返回值而且为 int;</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2055.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1011】union 和 struct区别：</p>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219/%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%2060a376ce82e74142a06d5cd5dfba4c7b.md">参考文章</a></p>
<p>  结构体(struct)中所有变量是“共存”的——优点是“有容乃大”，全面；缺点是struct内存空间的分配是粗放的，不管用不用，全分配。</p>
<p>  而联合体(union)中是各变量是“互斥”的——缺点就是不够“包容”；但优点是内存使用更为精细灵活，也节省了内存空间。</p>
<ul>
<li><p>首先是union：要点就是 成员共用内存首地址；示例代码，判断大小端；</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">var</span>&#123;</span>  <br>        <span class="hljs-type">char</span> c[<span class="hljs-number">4</span>];  <br>        <span class="hljs-type">int</span> i;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">var</span> <span class="hljs-title">data</span>;</span>  <br>        data.c[<span class="hljs-number">0</span>] = <span class="hljs-number">0x04</span>;<span class="hljs-comment">//因为是char类型，数字不要太大，算算ascii的范围~  </span><br>        data.c[<span class="hljs-number">1</span>] = <span class="hljs-number">0x03</span>;<span class="hljs-comment">//写成16进制为了方便直接打印内存中的值对比  </span><br>        data.c[<span class="hljs-number">2</span>] = <span class="hljs-number">0x02</span>;  <br>        data.c[<span class="hljs-number">3</span>] = <span class="hljs-number">0x11</span>;  <br><span class="hljs-comment">//数组中下标低的，地址也低，按地址从低到高，内存内容依次为：04,03,02,11。总共四字节！  </span><br><span class="hljs-comment">//而把四个字节作为一个整体（不分类型，直接打印十六进制），应该从内存高地址到低地址看，0x11020304，低位04放在低地址上。  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>,data.i);  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>【1022】32位机和64位机 C语言数据类型 哪些是固定大小的哪些是可变大小的：long 是可变大小的，在32位为4字节，64位为8字节；</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-STM32HAL-8-14-22d01922723e441a970d342ac41f20f9?pvs=21">指路——&gt;</a></p>
</li>
<li><p>【1022】使用异或 ^&#x3D; 交换两个数的值；不使用中间量； 关键在交换律和结合律；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2056.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1022】memcopy与memmove的区别：后者可以移动重叠的内存空间；【还要注意操作一个字节内存单元的方法。。  <em>( ( char</em> )src+i ) 取第i个字节的值】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2057.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">函数声明：<span class="hljs-type">void</span> * <span class="hljs-title function_">memmove</span> <span class="hljs-params">( <span class="hljs-type">void</span> * destination, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * source, <span class="hljs-type">size_t</span> num )</span>;<br><br>参数：<br><br>目的地：指向要在其中复制内容的目标数组的指针，类型转换为 <span class="hljs-type">void</span>* 类型的指针。<br><br>源：指向要复制的数据源的指针，类型转换为 <span class="hljs-type">const</span> <span class="hljs-type">void</span>* 类型的指针。<br><br>数字：要复制的字节数。（<span class="hljs-type">size_t</span> 是无符号整数类型）<br><br>返回值： 返回目的地。<br><br>头  文  件：<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br></code></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">My_memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>* dest , <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">size_t</span> num)</span><br>&#123;<br>	assert(dest &amp;&amp; src);<br>    <span class="hljs-type">void</span>* ret=dest;<br>	<span class="hljs-keyword">if</span> (dest &lt; src)<br>	&#123;<br>		<span class="hljs-keyword">while</span> (num--)<span class="hljs-comment">//前-&gt;后</span><br>		&#123;<br>			*(<span class="hljs-type">char</span>*)dest = *(<span class="hljs-type">char</span>*)src;<br>			dest = (<span class="hljs-type">char</span>*)dest + <span class="hljs-number">1</span>;<br>			src = (<span class="hljs-type">char</span>*)src + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">while</span> (num--)<span class="hljs-comment">//后-&gt;前</span><br>		&#123;<br>			*((<span class="hljs-type">char</span>*)dest+num) = *((<span class="hljs-type">char</span>*)src + num);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>【1027】需要补充 strcpy strncpy</p>
</li>
<li><p>【1025】【海兴电力】使用const修饰的变量，可以使用指针修改内存的方式改值</p>
</li>
<li><p>【1031】佰维存储 手写memcpy; memcpy的原则就是重叠部分保持原样；</p>
<p>  解决办法就是自顶向下copy</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2058.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/*---------------------手写memcpy---------------------*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_memcpy</span>(<span class="hljs-params"> <span class="hljs-built_in">char</span>* psrc, <span class="hljs-built_in">char</span>* pdst, <span class="hljs-built_in">int</span> n </span>)</span><br>&#123;<br>    <span class="hljs-comment">/* 考虑内存重叠的原因是 如果目标地址pdst在 psrc+n 范围内，那么就不能保证重叠部分保持原样的原则 */</span><br>    <span class="hljs-keyword">if</span>( psrc == NULL || pdst == NULL || n &lt;= <span class="hljs-number">0</span> )<br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span>( pdst &gt; psrc &amp;&amp; pdst &lt; psrc + n )<br>    &#123;<br>        <span class="hljs-comment">/* 跟数组一个道理 从0开始到 n-1 */</span><br>        psrc += ( n - <span class="hljs-number">1</span> );<br>        pdst += ( n - <span class="hljs-number">1</span> );<br>        <span class="hljs-keyword">while</span>( n-- )<br>        &#123;<br>            <span class="hljs-comment">/* *和-- 同优先级 且从右到左运算；--先结合，但是--在后，所以是先取值赋值之后在-- */</span><br>            *pdst-- = *psrc--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>( n-- )<br>        &#123;<br>            *pdst++ = *psrc++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*---------------------手写memcpy---------------------*/</span><br></code></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h3 id="深入的细节内容"><a href="#深入的细节内容" class="headerlink" title="深入的细节内容"></a>深入的细节内容</h3><ul>
<li><p>【1104】内存碎片：内部碎片、外部碎片；</p>
<p>  内存碎片是指在内存管理过程中产生的未被有效利用的零散、不连续的内存空间。主要分为两种类型：<strong>内部碎片</strong>和<strong>外部碎片</strong>。</p>
<ul>
<li>内部碎片：是由于固定大小的内存分配方式或<strong>对齐</strong>要求等原因导致的未被利用的小空间。当分配给进程的内存块大于所需的大小时，其中的<strong>剩余空间就成为了内部碎片</strong>。</li>
<li>外部碎片：是由于存在未分配的连续内存空间太小而不能满足分配请求，从而导致这些内存无法被有效利用。</li>
</ul>
<p>  解决内存碎片问题的方法可以包括：</p>
<ul>
<li>段页式管理：采用虚拟内存管理技术，将物理内存划分为不同的页或段，以更灵活地管理和分配内存空间，减少碎片化。</li>
<li>使用内存池：通过分配一定数量的内存块，由内存池来管理分配和回收，减少频繁的内存分配和释放，从而减少碎片化。</li>
</ul>
</li>
<li><p>【1104】为什么段页式能解决内存碎片问题：可以将用户程序的段映射到物理内存任意位置，增加了内存利用的灵活性；</p>
<ul>
<li>内存碎片是指内存中零散的、不连续的空闲空间，它们的总和可能可以满足某个进程的内存需求，但是由于它们的地址不连续或者太小，导致无法分配给该进程，造成内存的浪费和效率的降低。</li>
<li>内存碎片可以分为内部碎片和外部碎片。内部碎片是指已经分配给某个进程的内存空间中，没有被该进程使用的部分。外部碎片是指还没有分配给任何进程的内存空间中，由于太小或者不连续而无法分配给新的进程的部分。</li>
<li>段页式管理是一种结合了段式管理和页式管理的内存管理方式，它的基本思想是把用户程序分成若干个<strong>逻辑上的段</strong>，然后再把每个段分成若干个固定大小的页，每个页都有一个页号和一个页内偏移量，每个段都有一个段号和一个段内偏移量。这样，用户程序的地址空间就由段号、页号和页内偏移量三部分组成，称为段页式地址。</li>
<li>段页式管理能解决内存碎片问题的原因是：<ul>
<li>一方面，它利用了段式管理的优点，即可以根据用户程序的逻辑结构来划分段，使得每个段都有一定的意义和功能，方便用户编程和保护。同时，它也可以通过动态重定位和段表来实现虚拟存储器，<strong>即可以把用户程序的段映射到物理内存的任意位置，不需要连续的内存空间，从而增加了内存的利用率和灵活性。</strong></li>
<li>另一方面，它利用了页式管理的优点，即可以把每个段分成固定大小的页，使得每个页都可以映射到物理内存的任意页框，不需要考虑段的大小和位置，从而减少了外部碎片的产生。同时，它也可以通过页表和快表来实现地址转换和缺页中断，即可以在用户程序访问某个页时，动态地把该页调入内存，或者在内存不足时，把某个页换出内存，从而实现了按需分配和置换的策略，提高了内存的效率和性能。</li>
</ul>
</li>
</ul>
</li>
<li><p>【1104】memcpy和strcpy的区别：非常重要的一点 strcpy如果目标地址内存空间不够，会造成缓冲区溢出；</p>
<p>  strcpy：</p>
<ul>
<li>用于<strong>字符串拷贝</strong>。</li>
<li>源字符串中的内容会被复制到目标字符串中，<strong>直到遇到字符串结束符 ‘\0’</strong>。</li>
<li>目标字符串必须有足够的空间来存储被复制的内容，否则可能导致缓冲区溢出。</li>
</ul>
<p>  memcpy：</p>
<ul>
<li>用于<strong>字节级别的内存拷贝</strong>。</li>
<li>可以拷贝任意类型的内存块，不仅限于字符串。</li>
<li>不会检查字符串结束符，通过指定要拷贝的字节数进行拷贝。</li>
<li>可以用于拷贝部分或完整的数组、结构体等。</li>
</ul>
<p>  安全性：</p>
<ul>
<li>strcpy函数不进行源字符串长度的检查，如果源字符串太长，可能会导致目标字符串缓冲区溢出。</li>
<li>memcpy函数本身没有长度限制，应确保源和目标内存区域不会发生重叠，否则可能会导致数据损坏。</li>
<li>为了提高安全性，可以使用像strcpy_s、strncpy_s这样提供了长度限制的函数。</li>
</ul>
<p>  总结：</p>
<ul>
<li>strcpy适用于字符串拷贝，可以自动识别字符串结束符。</li>
<li>memcpy适用于字节级别的内存拷贝，适用于任意类型的数据。</li>
</ul>
</li>
<li><p>【1104】<strong><strong>一个变量既可以是const还可以是volatile类型吗：可以；外部可能会修改变量内存以达到修改const变量值的效果；</strong></strong></p>
<p>  可以，一个变量可以同时具有const和volatile。const表示变量的值不能被改变，而volatile属性表示变量的值可能会被外部程序改变。</p>
</li>
<li><p>【1104】常见的变量定义；数组指针，指针数组，指针函数：</p>
<ul>
<li><code>int a;</code>：定义了一个变量 <code>a</code>，它的类型是 <code>int</code>。</li>
<li><code>int *a;</code>：定义了一个指针 <code>a</code>，它指向 <code>int</code> 类型的变量。</li>
<li><code>int **a;</code>：定义了一个指针 <code>a</code>，它指向一个指向 <code>int</code> 类型的指针。</li>
<li><code>int a[10];</code>：定义了一个数组 <code>a</code>，该数组有 10 个元素，每个元素是 <code>int</code> 类型。</li>
<li><code>int *a[10];</code>：定义了一个数组 <code>a</code>，该数组有 10 个元素，每个元素是 <code>int</code> 类型的指针。</li>
<li><code>int (*a)[10];</code>：定义了一个指针 <code>a</code>，该指针指向一个数组，该数组有 10 个元素，每个元素是 <code>int</code> 类型。</li>
<li><code>int (*a)(int);</code>：定义了一个指针 <code>a</code>，该指针指向一个参数是 <code>int</code>，返回值是 <code>int</code> 的函数。</li>
<li><code>int (*a[10])(int);</code>：定义了一个数组 <code>a</code>，该数组的元素是一个指向参数是 <code>int</code>，返回值是 <code>int</code> 的函数指针。</li>
</ul>
</li>
<li><p>【1104】数组名和指针的区别：</p>
<p>  数组名：</p>
<ul>
<li>是一个常量指针，指向数组的首元素。</li>
<li>大小固定为整个数组的大小。</li>
<li>无法被改变或重新赋值。</li>
<li>无法进行指针运算。</li>
</ul>
<p>  指针：</p>
<ul>
<li>是一个变量，存储一个内存地址。</li>
<li>大小固定为指针类型的大小。</li>
<li>可以指向任意类型的对象。</li>
<li>可以被改变或重新赋值。</li>
<li>可以进行指针运算，如加法、减法等。</li>
</ul>
</li>
<li><p>【1104】数组到底存放在哪里：堆或栈；在堆中，使用malloc申请的数组，可以跨函数访问；</p>
<p>  <strong>数组在内存中存放的位置取决于数组的类型以及其定义的位置。在大多数情况下，数组被存储在栈内存或堆内存中。</strong></p>
<ol>
<li><strong>栈内存：局部变量和函数参数通常存储在栈内存中。当您在一个函数内部定义数组时，它会分配一块连续的内存区域，用于存储数组元素。这种分配的内存空间在函数执行完毕后会自动回收。</strong></li>
<li><strong>堆内存：当使用 malloc()、calloc() 或 new 等动态内存分配函数分配数组时，它会存储在堆内存中。堆内存需要手动分配和释放，可以在函数执行期间或跨函数访问。</strong></li>
</ol>
</li>
<li><p>【1104】C语言<strong>内存</strong>分布模型！图</p>
<p>  <a target="_blank" rel="noopener" href="https://uploadfiles.nowcoder.com/images/20231004/235444410_1696410005617/D2B5CA33BD970F64A6301FA75AE2EB22">https://uploadfiles.nowcoder.com/images/20231004/235444410_1696410005617&#x2F;D2B5CA33BD970F64A6301FA75AE2EB22</a></p>
<p>  上图是比较经典的内存分布的模型图，下面将对上图中的不同的组成部分进行详细解释（<strong>从低地址到高地址</strong>）注：<strong>必须知道组成结构但是具体的含义只需要理解。</strong></p>
<ol>
<li><strong>代码段</strong>：存放程序的机器指令（即二进制代码）。通常是只读的，因为程序的指令在执行过程中不应该被修改。【程序拷贝到内存中执行，或者XIP直接跳过内存进CPU】</li>
<li><strong>数据段</strong>：存放已初始化的全局变量和静态变量。这些变量在程序开始运行时已经赋予了初始值。</li>
<li><strong>BSS 段</strong>：存放未初始化的全局变量和静态变量。它们在程序开始运行时会自动初始化为0或者空指针。</li>
<li><strong>堆区</strong>：动态分配的内存空间，用于存放程序运行时动态申请的内存。（程序员可以通过函数（如malloc、calloc等）或者操作系统提供的接口来申请和释放堆内存，堆从低地址向高地址增长。）</li>
<li><strong>栈区</strong>：<strong>存放函数的局部变量、函数参数值以及函数调用和返回时的相关信息</strong>。栈区是按照“<strong>先进后出</strong>”的原则进行管理，内存的分配和释放是自动进行的，栈从高地址向低地址增长。是一块连续的空间。</li>
<li><strong>共享区</strong>：也称为文件映射或共享内存，用于实现不同进程之间的内存共享。</li>
</ol>
</li>
<li><p>【1104】初始化全0的变量保存在bss段还是Data段？：BSS</p>
<p>  初始化为0的全局变量通常会被分配到程序的BSS（Block Started by Symbol）段。BSS段是用于存放未初始化或初始化为0的全局变量和静态变量的一部分内存空间。在程序加载时，系统会自动将BSS段中的变量初始化为0。</p>
<p>  已经明确初始化为非零值的全局变量会被分配到程序的数据（Data）段。Data段用于存放已经初始化的全局变量和静态变量。</p>
<p>  总结来说，初始化为0的全局变量通常会被分配到BSS段，而已初始化为非零值的全局变量则会被分配到Data段。</p>
</li>
<li><p>【1104】内存泄漏具体定义</p>
<p>  <strong>内存泄漏是指在程序运行过程中，分配的内存没有被及时释放，导致这部分内存无法再被程序使用。长时间运行或发生频繁的内存泄漏可能导致系统资源不足，性能下降或程序崩溃。</strong></p>
</li>
<li><p>【1104】虚拟内存和物理内存的含义与区别：</p>
<p>  <strong>虚拟内存（Virtual Memory）和物理内存（Physical Memory）是计算机系统中存储和管理数据的两个概念：</strong></p>
<ul>
<li>物理内存是计算机中的实际硬件内存，由RAM芯片组成。</li>
<li>虚拟内存是对物理内存的扩展，使用<strong>磁盘空间</strong>来模拟更大的内存容量。</li>
</ul>
<p>  <strong>它们之间的区别包括：</strong></p>
<ul>
<li>大小：物理内存的容量是固定的，而虚拟内存的大小可以超过物理内存的容量。</li>
<li>访问速度：物理内存的访问速度较快，而虚拟内存的访问速度相对较慢，因为它需要与磁盘进行交互。</li>
<li>地址空间：物理内存使用物理地址进行访问，而虚拟内存使用虚拟地址，<strong>通过内存管理单元（MMU）映射到物理内存。</strong></li>
<li>管理方式：物理内存的管理相对简单，而虚拟内存的管理涉及<strong>页表和页面</strong>置换等技术。</li>
<li>可用空间：物理内存的可用空间有限，而虚拟内存可以提供更大的可用空间，因为它可以使用磁盘空间作为扩展。</li>
</ul>
<p>  总之，虚拟内存扩展了物理内存的容量，并提供了更灵活的内存管理机制，但付出的代价是访问速度较慢。
  </p>
</li>
<li><p>【1104】<strong><strong>在1G内存的计算机中能否malloc(1.2G)？为什么？——可以，因为申请的是虚拟内存；</strong></strong></p>
<p>  是有可能申请1.2G的内存的。</p>
<p>  <strong>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。</strong>根据 <code>malloc</code> 函数的作用和原理，应用程序通过 <code>malloc</code> 函数<strong>在虚拟地址空间中申请内存</strong>，并且与物理内存没有直接的关系。 <code>malloc</code> 返回的是在虚拟地址空间中的地址，而物理内存的分配是由操作系统完成的。</p>
<p>  假设我们需要申请的内存大小为 1.2GB，转换为字节为 2^30 × 1.2 Byte，这个数值仍然在 <code>unsigned int</code> 的表示范围内。因为 <code>malloc</code> 函数需要一个 <code>unsigned int</code> 类型的参数来指定内存大小。</p>
<p>  在当前使用的 Windows 环境中，可申请的最大内存空间通常超过 1.9GB。然而，具体可申请的内存大小受到操作系统版本、程序本身的大小、动态&#x2F;共享库的使用情况、程序栈的大小等因素的影响。每次运行的结果可能存在差异，因为有些操作系统使用随机地址分布技术，导致进程的堆空间变小。</p>
<p>  综上所述，根据 <code>malloc(size_t)</code> 函数的调用，是有可能申请超过机器物理内存大小的内存块的。</p>
</li>
<li><p>【1104】直接访问内存地址：<code>unsigned char* p = (unsigned char*)0x3355;  // 将地址转换为无符号字符型指针类型</code> 【1119】还是加一个volatile好些： ( volatile unsigned char* )</p>
</li>
<li><p>【1104】C语言函数压栈顺序：一直都是从右到左：</p>
<p>  函数参数压栈顺序是指在函数调用过程中，函数的参数是如何在栈上被压入内存的顺序。</p>
<p>  在C&#x2F;C++中，有两种常见的调用方式：__stdcall和__cdecl。下面是对它们的简要说明：</p>
<ol>
<li>__stdcall调用方式：<strong>在__stdcall调用方式下，函数的参数是从右往左依次压入栈中。被调函数负责清理栈上的参数。__stdcall调用方式通常被用于Win32 API，因为它具有固定的参数顺序，方便调用方和被调用方之间的交互。</strong></li>
<li>__cdecl调用方式：<strong>在__cdecl调用方式下，函数的参数是从右往左依次压入栈中。调用方负责清理栈上的参数。__cdecl调用方式是C&#x2F;C++默认的函数调用方式。</strong></li>
</ol>
<p>  <strong>使用__stdcall调用方式的主要原因是为了确保与其他代码库或操作系统的交互的正确性和一致性，两种不同的调用方式的区别就是为什么应对不同库的一致性和兼容性。</strong>
  </p>
</li>
<li><p>【1104】CPU工作原理：取值，译码，执行，访问内存，写回</p>
<ol>
<li><strong>取指令（Instruction Fetch）：</strong>CPU 从内存中获取当前要执行的指令。CPU 会根据指令寄存器中的指令地址，<strong>将指令从内存中读取到指令缓存</strong>（Instruction Cache）中。</li>
<li><strong>解码指令（Instruction Decode）：</strong>CPU 解析指令，确定指令的 操作类型（如加载、存储、运算等），以及操作的操作数（如寄存器、内存地址等）。</li>
<li><strong>执行指令（Execute）：</strong>CPU 根据指令的操作类型和操作数执行相应的操作。这可能涉及数据的加载、存储、算术运算、逻辑运算、分支跳转等操作。</li>
<li><strong>访问内存（Memory Access）：</strong>如果指令需要访问内存（如加载、存储操作），CPU 将计算出需要读取或写入的内存地址，并将数据从内存中读取或写入。</li>
<li><strong>写回结果（Write Back）：</strong>如果执行的指令产生了结果，CPU 将结果写回到寄存器或内存中，以便后续的指令可以使用这些结果。</li>
</ol>
</li>
<li><p>【1104】堆和栈的区别 【详细】注意生命周期，在堆上分配的内存需要手动释放，不会因为函数执行结束而释放；栈不会产生内存碎片问题；</p>
<p>  <strong>堆栈空间分配不同：</strong></p>
<ul>
<li>栈由操作系统自动进行分配和释放，用于存放函数的参数值、局部变量的值等，具有高效性。</li>
<li>堆一般由程序员手动进行分配和释放，效率比栈低很多。</li>
</ul>
<p>  <strong>堆栈缓存方式不同：</strong></p>
<ul>
<li>栈使用一级缓存，存储在处理器核心中，调用完成后立即释放，速度较快。</li>
<li>堆存储在二级缓存或主存中，速度相对较慢。</li>
</ul>
<p>  <strong>生长方向</strong>：</p>
<ul>
<li>堆：堆的分配方向是向上的，即向地址较大的方向分配。当堆需要扩展时，会向高地址方向增长。</li>
<li>栈：栈的分配方向是向下的，即向地址较小的方向分配。当栈需要扩展时，会向低地址方向增长。</li>
</ul>
<p>  <strong>生命周期：</strong></p>
<ul>
<li>堆：堆上的内存在分配时并不会被立即释放，需要手动进行内存释放操作。堆上的数据可以在程序的任意位置进行访问，不受函数的调用关系限制。</li>
<li>栈：栈上的内存分配和释放是自动进行的，随着函数的调用和返回进行相应的操作。栈上的数据只在特定的作用域内有效，函数执行完成后会自动释放。</li>
</ul>
<p>  <strong>空间大小：</strong></p>
<ul>
<li>栈的空间大小一般较小，通常最多为2MB，超过则会报溢出错误。</li>
<li>堆的空间比较大，理论上可以接近3GB（对于32位程序来说）。</li>
</ul>
<p>  <strong>能否产生碎片：</strong></p>
<ul>
<li>栈操作遵循”后进先出”的原则，不会有内存块从栈中弹出，因此不会产生碎片。</li>
<li>堆是通过动态分配内存的方式进行分配和释放，频繁的申请和释放内存可能会引发内存碎片问题。</li>
</ul>
</li>
</ul>
<h3 id="C语言运算符"><a href="#C语言运算符" class="headerlink" title="C语言运算符"></a>C语言运算符</h3><ul>
<li><p>C语言运算符优先级 ！！！</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2059.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>a &#x3D; b &#x3D;c; a 是多少 a和c的值一样；从右到左运算，c先赋值给b，b再赋值给a</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2060.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【根据优先级 ++ &gt; +】a &#x3D; 5, b &#x3D; 7; c &#x3D; a+++b?    ——&gt; a++ +b;  ——&gt; c &#x3D; 12; a &#x3D; 6; b &#x3D; 7;</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2061.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
<h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><ul>
<li><p>基本问题</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abap">RTOS背景知识<br>临界段代码保护<br>任务的四种状态<br>任务优先级<br>任务创建与删除<br>任务挂起与恢复<br>列表与列表项<br>队列<br>4种信号量<br>事件标志组<br>任务通知<br>空闲任务<br></code></pre></td></tr></table></figure>
</li>
<li><p>【1009】一个操作系统都包含什么？</p>
</li>
<li><p>简述一下什么是RTOS系统</p>
<p>  RTOS是实时操作系统的缩写，它是一种能够在规定的时间内响应外部事件或数据的操作系统。RTOS与普通操作系统的区别主要在于<strong>实时性，即任务的执行时间是确定的</strong>，不会有较大的延迟或抖动。RTOS通常用于嵌入式设备或需要高度可靠性和实时性的领域，如工业自动化、机器人、航空航天等。<a target="_blank" rel="noopener" href="https://blog.csdn.net/mxh3600/article/details/124500906">1</a></p>
<p>  RTOS的设计理念和调度算法也与普通操作系统有所不同，它们需要考虑任务的优先级、中断延时、线程切换延时、内存管理、系统服务等方面，以保证系统的实时性和稳定性。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">4</a></p>
<p>  一些常见的RTOS有VxWorks, RT-Thread, FreeRTOS, QNX, Windows CE等，它们各有各的特点和应用场景。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">4</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/mxh3600/article/details/124500906">1</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E4%BB%80%E4%B9%88%E6%98%AFRTOS%E7%B3%BB%E7%BB%9F">2</a></p>
</li>
<li><p>FreeRTOS和Linux区别</p>
<p>  FreeRTOS主要给MCU，Linux主要跑在SoC上 CortexA系列等；FreeRTOS占用资源比Linux少，功能也少，内核只有三个文件。可移植性可裁剪性FreeRTOS也比Linux好。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs abap">FreeRTOS和Linux系统的区别是什么呢？这是一个很好的问题，我尝试为你解答一下。<br><br>FreeRTOS和Linux系统都是操作系统，但它们的设计目标和应用场景不同。FreeRTOS是一个轻量级的实时操作系统，主要用于嵌入式系统和实时应用，例如智能家居、工业控制、汽车电子等。Linux是一个通用的操作系统，适用于各种场景，包括桌面、服务器和嵌入式系统，例如个人电脑、智能手机、平板电脑等。<br><br>FreeRTOS和Linux系统的区别主要体现在以下几个方面：<br><br>- 资源占用：FreeRTOS占用的资源非常少，内核只有三个.c文件，可以运行在各种处理器和微控制器上，包括ARM、MIPS、X86等。Linux占用的资源相对较多，需要更大的内存和存储空间，一般运行在较强大的处理器和架构上，例如X86、ARM、PowerPC等。<br>- 功能范围：FreeRTOS主要实现了任务调度、内存管理、IPC、中断管理这几个模块，它要求快速的处理任务，GUI、驱动框架、Shell这些都不是它的核心功能，而且大部分情况下都不会做。Linux实现了更多的功能，包括文件系统、网络协议、驱动程序、应用程序等，它的第一要务是让用户能够方便地使用电脑和利用计算机资源。<br>- 实时性能：FreeRTOS具有很强的实时性能，它可以保证任务在规定的时间内完成，并提供了各种实时机制和中断处理能力。Linux的实时性能相对较差，它不能保证任务在规定的时间内完成，并且受到内核抢占和中断延迟等因素的影响。<br>- 可裁剪性：FreeRTOS具有很强的可裁剪性，它可以根据不同的应用需求和硬件条件进行定制和优化，只保留必要的功能模块。Linux的可裁剪性相对较弱，它虽然也可以进行一定程度的定制和优化，但是不能完全去除不需要的功能模块。<br>- 可移植性：FreeRTOS具有很强的可移植性，它可以轻松地移植到不同的处理器和平台上，并提供了各种开发工具和支持。Linux的可移植性相对较弱，它虽然也可以移植到不同的处理器和平台上，但是需要更多的工作量和技术支持。<br><br>以上就是FreeRTOS和Linux系统的区别的简要介绍，希望对你有所帮助。😊<br><br>如果你想了解更多关于这两个操作系统的信息，你可以参考以下链接：<br><br>- [1](^1^)：一篇介绍freertos与linux区别的文章<br>- [2](^2^)：一篇比较freertos和linux优缺点的文章<br>- [3](^3^)：一个关于freertos和linux区别的知乎问答<br><br>源: 与必应的对话， 2023/9/1<br>(1) freertos与linux区别 - 嵌入式操作系统 - 电子发烧友网. https://www.elecfans.com/emb/xitong/202004161204583.html.<br>(2) freertos和Linux比较 - 知乎. https://zhuanlan.zhihu.com/p/624320046.<br>(3) 为什么称FreeRTOS为轻量级OS，和Linux相比，有哪些具体 .... https://www.zhihu.com/question/28564079.<br></code></pre></td></tr></table></figure>
</li>
<li><p>【1104】STM32上电启动流程 BOOTROM —&gt;Reset_Handler —&gt;SystemInit—&gt;__main() —&gt; main()</p>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219/STM32%20_main%20%E9%87%8C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%20e3ba4e655b4a4d76ae74514ccf1c0915.md"><strong><strong>STM32 _main 里做了什么</strong></strong></a></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2062.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2063.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>STM32 FreeRTOS 上电启动流程？</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/STM32-1-ad61c27b3f4e4a1abb355724c93e2a98?pvs=21">首先是STM32启动流程</a> 那张图要背清楚；</p>
<p>  然后才是FreeRTOS启动：</p>
<p>  <strong>vTaskStartScheduler</strong> 启动调度器 创建空闲任务 ——&gt;**<a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">prvStartFirstTask</a>**启动第一个任务 + <strong>vPortSetupTimerInterrupt</strong> 初始化Systick ——&gt; <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">SVC 0 指令调用 SVCHandler</a> 真正启动第一个任务</p>
<p>  SVC 0 就是调用SVC 0号服务，也就是SVC_Handler。</p>
<p>  SVC_Handler 中 获取第一个任务的TaskTCB 任务控制块，然后将任务栈中的数据弹出，也就是那十五个寄存器，当然包括PC，这样就会跳到任务的位置执行；</p>
<p>  我怎么知道执行哪个任务？【<strong>pxCurrentTCB 指向的是最高优先级的 Ready 状态的任务指针</strong>】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2064.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h3 id="非常详细的FreeRTOS调度器解析"><a href="#非常详细的FreeRTOS调度器解析" class="headerlink" title="非常详细的FreeRTOS调度器解析"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutaopower/article/details/107057528#:~:text=FreeRTOS%20--%EF%BC%889%EF%BC%89%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B9%8B%E5%90%AF%E5%8A%A8%E8%B0%83%E5%BA%A6%E5%99%A8%201%201%E3%80%81%20vTaskStartScheduler%20vTaskStartScheduler%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9C%A8%20task.c,the%20validity%20of%20an%20interrupt%20priority.%20%2A%2F%20">非常详细的FreeRTOS调度器</a>解析</h3><p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2065.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1016】STM32启动选项 <a target="_blank" rel="noopener" href="https://www.notion.so/STM32_HAL-2023-10-15-996797e72af14652b327f262d8b0ad9f?pvs=21">指路——&gt;</a></p>
</li>
<li><p>STM32 FreeRTOS 任务切换原理？</p>
<p>  Systick_Handler、PendSV_Handler是最低优先级；</p>
<p>  <a target="_blank" rel="noopener" href="https://stephenzhou.blog.csdn.net/article/details/107081495">非常详解——&gt;</a></p>
<p>  首先，触发任务切换的原因有很多，有Systick Handler调用，也有手动调用 portYIELD()函数切换，归根结底是将PendSV寄存器中的某位置位，等到中断全都执行结束之后，<a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">轮到PendSV中断执行</a>，此时才会进行任务切换。</p>
<p>  首先，将currentTCB指向的任务寄存器入栈，就是那十五个寄存器，然后调用 vTaskSwitchContext 函数找到就绪任务列表中优先级最大的任务进行切换，将任务的堆栈弹出到寄存器，跳到该任务处运行。</p>
</li>
<li><p>任务切换原理详解，这篇文章背下来基本上就够了</p>
<ul>
<li><p>连接</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/kunkliu/article/details/125938102">https://blog.csdn.net/kunkliu/article/details/125938102</a></p>
</li>
<li><p>文章</p>
<h1 id="vTaskSwitchContext"><a href="#vTaskSwitchContext" class="headerlink" title="vTaskSwitchContext"></a><strong>vTaskSwitchContext</strong></h1><h2 id="blog-csdn-net-kunkliu-article-details-125938102-https-g-csdnimg-cn-static-logo-favicon32-ico-FreeRTOS-专栏收录该内容-34-篇文章-57-订阅-订阅专栏-1-任务切换相关API函数-函数-描述-—-—-xPortPendSVHandler-PendSV中断服务函数，其实函数原型为PendSV-Handler-vTaskSwitchContext-检查任务堆栈使用是否溢出，和查找下一个优先级高的任务，如果使能运行时间统计功能，会计算任务运行时间-2-任务切换的基本知识-在FreeRTOS任务管理中，最主要的目的就是找到就绪态优先级最高的任务，然后执行任务切换，从而能保持优先级最高的任务一直占用CPU资源。为了达到最优性能，任务切换部分程序使用汇编代码编写。-FreeRTOS有两种方法触发任务切换：-系统节拍时钟中断-SysTick定时器-。切换过程参考《FreeRTOS原理剖析：系统节拍时钟分析》-执行系统调用代码。普通任务使用taskYIELD-强制任务切换；中断服务程序使用portYIELD-FROM-ISR-强制任务切换；在应用程序里也可以通过设置xYieldPending的值来通知调度器进行任务切换。-其中：-可以看出，最终执行的代码段为：-通过向中断控制及状态寄存器ICSR-地址：0xE000-ED04-的第28位写入1，触发PendSV中断，从而执行任务切换。-3-任务切换过程-3-1-PendSV中断服务函数分析-在FreeRTOS中，有：-源代码如下：-说明：-在Cortex-M处理器中有两个栈指针，一个是主栈指针-Main-Stack-Pointer，即MSP-，它可用于线程模式，在中断模式下只能用MSP；另一个是进程堆栈指针-Processor-Stack-Pointer，即PSP-，PSP总是用于线程模式。在任何时刻只能使用到其中一个。-复位后处于线程模式特权级，默认使用MSP。在FreeRTOS中，MSP用于OS内核和异常处理，PSP用于应用任务。-通过设置CONTROL寄存器的bit-1-选择使用哪个堆栈指针。CONTROL-1-0选择主堆栈指针；CONTROL-1-1选择进程堆栈指针。-3-2-函数vTaskSwitchContext-该函数会更新当前任务运行时间，检查任务堆栈使用是否溢出，然后调用宏-taskSELECT-HIGHEST-PRIORITY-TASK-获取更高优先级的任务。-函数源代码如下：-3-2-寻找下一个任务的方式-PendSV中会调用vTaskSwitchContext-，最后调用函数taskSELECT-HIGHEST-PRIORITY-TASK-寻找优先级最高的任务。-对于FreeRTOS的调度器，它有两种方式寻找下一个最高优先级的任务，分别为特殊方式和常用方式，在FreeRTOSConfig-h中可通过宏定义设置，如下：-在FreeRTOS中，通用方法不依赖某些硬件等限制，适用于多种MCU中。特殊方式是使用了某些硬件的特性，只针对部分MCU而使用。-3-2-1-常用方法-uxTopReadyPriority-记录就绪态中最高优先级值，创建任务时会更新值，有任务添加到就绪表时也会更新值。这种方法对任务的数量无限制。-3-2-2-特殊方式-使用此方法，uxTopReadyPriority-每个bit位表示一个优先级，bit0表示优先级0，bit31表示优先级31，使用此方式优先级最大只能是32个。-其中：-clz-uxReadyPriorities-是计算uxReadyPriorities-的前导零个数，如：-二进制0001-1010-0101-1111的前导零个数为3，可以知道，最高优先级uxTopPriority-等于-31减去前导零个数。-知道最高优先级的优先级，则通过listGET-OWNER-OF-NEXT-ENTRY-对应最高优先级的列表项，将pxCurrentTCB指向对应的控制块。"><a href="#blog-csdn-net-kunkliu-article-details-125938102-https-g-csdnimg-cn-static-logo-favicon32-ico-FreeRTOS-专栏收录该内容-34-篇文章-57-订阅-订阅专栏-1-任务切换相关API函数-函数-描述-—-—-xPortPendSVHandler-PendSV中断服务函数，其实函数原型为PendSV-Handler-vTaskSwitchContext-检查任务堆栈使用是否溢出，和查找下一个优先级高的任务，如果使能运行时间统计功能，会计算任务运行时间-2-任务切换的基本知识-在FreeRTOS任务管理中，最主要的目的就是找到就绪态优先级最高的任务，然后执行任务切换，从而能保持优先级最高的任务一直占用CPU资源。为了达到最优性能，任务切换部分程序使用汇编代码编写。-FreeRTOS有两种方法触发任务切换：-系统节拍时钟中断-SysTick定时器-。切换过程参考《FreeRTOS原理剖析：系统节拍时钟分析》-执行系统调用代码。普通任务使用taskYIELD-强制任务切换；中断服务程序使用portYIELD-FROM-ISR-强制任务切换；在应用程序里也可以通过设置xYieldPending的值来通知调度器进行任务切换。-其中：-可以看出，最终执行的代码段为：-通过向中断控制及状态寄存器ICSR-地址：0xE000-ED04-的第28位写入1，触发PendSV中断，从而执行任务切换。-3-任务切换过程-3-1-PendSV中断服务函数分析-在FreeRTOS中，有：-源代码如下：-说明：-在Cortex-M处理器中有两个栈指针，一个是主栈指针-Main-Stack-Pointer，即MSP-，它可用于线程模式，在中断模式下只能用MSP；另一个是进程堆栈指针-Processor-Stack-Pointer，即PSP-，PSP总是用于线程模式。在任何时刻只能使用到其中一个。-复位后处于线程模式特权级，默认使用MSP。在FreeRTOS中，MSP用于OS内核和异常处理，PSP用于应用任务。-通过设置CONTROL寄存器的bit-1-选择使用哪个堆栈指针。CONTROL-1-0选择主堆栈指针；CONTROL-1-1选择进程堆栈指针。-3-2-函数vTaskSwitchContext-该函数会更新当前任务运行时间，检查任务堆栈使用是否溢出，然后调用宏-taskSELECT-HIGHEST-PRIORITY-TASK-获取更高优先级的任务。-函数源代码如下：-3-2-寻找下一个任务的方式-PendSV中会调用vTaskSwitchContext-，最后调用函数taskSELECT-HIGHEST-PRIORITY-TASK-寻找优先级最高的任务。-对于FreeRTOS的调度器，它有两种方式寻找下一个最高优先级的任务，分别为特殊方式和常用方式，在FreeRTOSConfig-h中可通过宏定义设置，如下：-在FreeRTOS中，通用方法不依赖某些硬件等限制，适用于多种MCU中。特殊方式是使用了某些硬件的特性，只针对部分MCU而使用。-3-2-1-常用方法-uxTopReadyPriority-记录就绪态中最高优先级值，创建任务时会更新值，有任务添加到就绪表时也会更新值。这种方法对任务的数量无限制。-3-2-2-特殊方式-使用此方法，uxTopReadyPriority-每个bit位表示一个优先级，bit0表示优先级0，bit31表示优先级31，使用此方式优先级最大只能是32个。-其中：-clz-uxReadyPriorities-是计算uxReadyPriorities-的前导零个数，如：-二进制0001-1010-0101-1111的前导零个数为3，可以知道，最高优先级uxTopPriority-等于-31减去前导零个数。-知道最高优先级的优先级，则通过listGET-OWNER-OF-NEXT-ENTRY-对应最高优先级的列表项，将pxCurrentTCB指向对应的控制块。" class="headerlink" title="  **blog.csdn.net**&#x2F;kunkliu&#x2F;article&#x2F;details&#x2F;125938102  https://g.csdnimg.cn/static/logo/favicon32.ico  FreeRTOS 专栏收录该内容    34 篇文章 57 订阅  订阅专栏  ### 1. 任务切换相关API函数  | 函数 | 描述 |  | — | — |  | xPortPendSVHandler() | PendSV中断服务函数，其实函数原型为PendSV_Handler() |  | vTaskSwitchContext() | 检查任务堆栈使用是否溢出，和查找下一个优先级高的任务，如果使能运行时间统计功能，会计算任务运行时间 |  ### 2. 任务切换的基本知识  在FreeRTOS任务管理中，最主要的目的就是找到就绪态优先级最高的任务，然后执行任务切换，从而能保持优先级最高的任务一直占用CPU资源。为了达到最优性能，任务切换部分程序使用汇编代码编写。  FreeRTOS有两种方法触发任务切换：  - 系统节拍时钟中断(SysTick定时器)。切换过程参考《FreeRTOS原理剖析：系统节拍时钟分析》  - 执行系统调用代码。普通任务使用taskYIELD()强制任务切换；中断服务程序使用portYIELD_FROM_ISR()强制任务切换；在应用程序里也可以通过设置xYieldPending的值来通知调度器进行任务切换。  其中：      可以看出，最终执行的代码段为：    通过向中断控制及状态寄存器ICSR(地址：0xE000 ED04)的第28位写入1，触发PendSV中断，从而执行任务切换。  ### 3. 任务切换过程  ### 3.1 PendSV中断服务函数分析  在FreeRTOS中，有：    源代码如下：    }  说明：  - 在Cortex-M处理器中有两个栈指针，一个是主栈指针(Main Stack Pointer，即MSP)，它可用于线程模式，在中断模式下只能用MSP；另一个是进程堆栈指针(Processor Stack Pointer，即PSP)，PSP总是用于线程模式。在任何时刻只能使用到其中一个。  - 复位后处于线程模式特权级，默认使用MSP。在FreeRTOS中，MSP用于OS内核和异常处理，PSP用于应用任务。  - 通过设置CONTROL寄存器的bit[1]选择使用哪个堆栈指针。CONTROL[1]&#x3D;0选择主堆栈指针；CONTROL[1]&#x3D;1选择进程堆栈指针。  ### 3.2 函数vTaskSwitchContext()  该函数会更新当前任务运行时间，检查任务堆栈使用是否溢出，然后调用宏 taskSELECT_HIGHEST_PRIORITY_TASK()获取更高优先级的任务。  函数源代码如下：    }  ### 3.2 寻找下一个任务的方式  PendSV中会调用vTaskSwitchContext()，最后调用函数taskSELECT_HIGHEST_PRIORITY_TASK()寻找优先级最高的任务。  对于FreeRTOS的调度器，它有两种方式寻找下一个最高优先级的任务，分别为特殊方式和常用方式，在FreeRTOSConfig.h中可通过宏定义设置，如下：    在FreeRTOS中，通用方法不依赖某些硬件等限制，适用于多种MCU中。特殊方式是使用了某些硬件的特性，只针对部分MCU而使用。  ### 3.2.1 常用方法  uxTopReadyPriority 记录就绪态中最高优先级值，创建任务时会更新值，有任务添加到就绪表时也会更新值。这种方法对任务的数量无限制。    }  ### 3.2.2 特殊方式  使用此方法，uxTopReadyPriority 每个bit位表示一个优先级，bit0表示优先级0，bit31表示优先级31，使用此方式优先级最大只能是32个。    }  其中：    __clz( ( uxReadyPriorities ) 是计算uxReadyPriorities 的前导零个数，如：  二进制0001 1010 0101 1111的前导零个数为3，可以知道，最高优先级uxTopPriority 等于 31减去前导零个数。  知道最高优先级的优先级，则通过listGET_OWNER_OF_NEXT_ENTRY()对应最高优先级的列表项，将pxCurrentTCB指向对应的控制块。
  "></a>  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/kunkliu/article/details/125938102">blog.csdn.net**&#x2F;kunkliu&#x2F;article&#x2F;details&#x2F;125938102</a><br><br>  <a target="_blank" rel="noopener" href="https://g.csdnimg.cn/static/logo/favicon32.ico">https://g.csdnimg.cn/static/logo/favicon32.ico</a><br><br>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/kunkliu/category_11583765.html">FreeRTOS 专栏收录该内容</a><br><br>  <img src="https://img-blog.csdnimg.cn/20190927151132530.png?x-oss-process=image/resize,m_fixed,h_224,w_224" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190927151132530.png?x-oss-process=image/resize,m_fixed,h_224,w_224"><br><br>  34 篇文章 57 订阅<br><br>  订阅专栏<br><br>  ### <strong>1. 任务切换相关API函数</strong><br><br>  | 函数 | 描述 |<br>  | — | — |<br>  | xPortPendSVHandler() | PendSV中断服务函数，其实函数原型为PendSV_Handler() |<br>  | vTaskSwitchContext() | 检查任务堆栈使用是否溢出，和查找下一个优先级高的任务，如果使能运行时间统计功能，会计算任务运行时间 |<br><br>  ### <strong>2. 任务切换的基本知识</strong><br><br>  在FreeRTOS任务管理中，最主要的目的就是找到就绪态优先级最高的任务，然后执行任务切换，从而能保持优先级最高的任务一直占用CPU资源。为了达到最优性能，任务切换部分程序使用汇编代码编写。<br><br>  FreeRTOS有两种方法触发任务切换：<br><br>  - 系统节拍时钟中断(SysTick定时器)。切换过程参考<a target="_blank" rel="noopener" href="https://mp.csdn.net/mdeditor/102075779#">《FreeRTOS原理剖析：系统节拍时钟分析》</a><br>  - 执行系统调用代码。普通任务使用taskYIELD()强制任务切换；中断服务程序使用portYIELD_FROM_ISR()强制任务切换；在应用程序里也可以通过设置xYieldPending的值来通知调度器进行任务切换。<br><br>  其中：<br><br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于普通任务时</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskYIELD()				portYIELD()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portYIELD_WITHIN_API 	portYIELD</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><br><br>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 对于中断服务程序时</span><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">portEND_SWITCHING_ISR</span>( xSwitchRequired ) <span class="hljs-built_in">if</span>( xSwitchRequired != pdFALSE ) <span class="hljs-built_in">portYIELD</span>()<br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">portYIELD_FROM_ISR</span>( x ) <span class="hljs-built_in">portEND_SWITCHING_ISR</span>( x )<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><br><br>  可以看出，最终执行的代码段为：<br><br>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define portYIELD()											\</span><br>&#123;															<span class="hljs-string">\</span><br>	<span class="hljs-comment">/* 														\</span><br><span class="hljs-comment">	 * 通过向中断控制及状态寄存器ICSR的第28位写入1,触发PendSV中断	\</span><br><span class="hljs-comment">	 * 地址为0xE000 ED04 									\</span><br><span class="hljs-comment">	 */</span>														<span class="hljs-string">\</span><br>	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;			<span class="hljs-string">\</span><br>															<span class="hljs-string">\</span><br>	<span class="hljs-comment">/* dsb和isb 完成数据同步隔离和指令同步隔离					\</span><br><span class="hljs-comment">	 * 保证之前存储器访问操作和指令都执行完						\</span><br><span class="hljs-comment">	 */</span>														<span class="hljs-string">\</span><br>	__dsb( portSY_FULL_READ_WRITE );						<span class="hljs-string">\</span><br>	__isb( portSY_FULL_READ_WRITE );						<span class="hljs-string">\</span><br>&#125;<br><br></code></pre></td></tr></table></figure><br><br>  通过向中断控制及状态寄存器ICSR(地址：0xE000 ED04)的第28位写入1，触发PendSV中断，从而执行任务切换。<br><br>  ### <strong>3. 任务切换过程</strong><br><br>  ### <strong>3.1 PendSV中断服务函数分析</strong><br><br>  在FreeRTOS中，有：<br><br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler 	PendSV_Handler</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br><br>  源代码如下：<br><br>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">__asm</span> void xPortPendSVHandler( void )<br>&#123;<br>	<span class="hljs-meta">extern</span> uxCriticalNesting<span class="hljs-comment">;</span><br>	<span class="hljs-meta">extern</span> pxCurrentTCB<span class="hljs-comment">;		/* 永远会指向当前激活的任务 */</span><br>	<span class="hljs-meta">extern</span> vTaskSwitchContext<span class="hljs-comment">;</span><br><span class="hljs-symbol">PRESERVE8</span><br><br><span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, psp					<span class="hljs-comment">/* 读取进程栈指针PSP，保存在R0中，此时SP的值为MSP */</span><br><span class="hljs-keyword">isb</span>							<span class="hljs-comment">/* 指令同步隔离 */</span><br><br><span class="hljs-comment">/* 这两句使R2中保存当前激活的任务TCB首地址 */</span><br><span class="hljs-keyword">ldr</span>	<span class="hljs-built_in">r3</span>, <span class="hljs-symbol">=pxCurrentTCB</span>		<span class="hljs-comment">/* 将pxCurrentTCB储存的地址保存到R3，注意的是pxCurrentTCB的储存地址是固定不变的，但指向是可变的 */</span><br><span class="hljs-keyword">ldr</span>	<span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r3</span>]				<span class="hljs-comment">/* 将R3地址所处数据保存在R2，即TCB的首地址 */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 前两句判断是否使能了FPU，如果使能了，则手动将s16~s31压入栈中</span><br><span class="hljs-comment"> * 其中s0~s15和FPSCR硬件自动完成</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">tst</span> <span class="hljs-built_in">r14</span>, <span class="hljs-number">#0x10</span><br><span class="hljs-keyword">it</span> eq<br><span class="hljs-symbol">vstmdbeq</span> <span class="hljs-built_in">r0</span>!, &#123;<span class="hljs-built_in">s16</span>-<span class="hljs-built_in">s31</span>&#125;<br><br><span class="hljs-comment">/* 将当前激活任务的寄存器值入栈，并更新R0，另外硬件自动将xPSR、PC、LR、R12、R0~R3入栈 */</span><br><span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">r0</span>!, &#123;<span class="hljs-built_in">r4</span>-<span class="hljs-built_in">r11</span>, <span class="hljs-built_in">r14</span>&#125;<br><br><span class="hljs-comment">/* R0为PSP地址，R2为激活任务的TCB地址，R0的值写入R2所保存的地址去，即TCB第一个成员指向线程堆栈指针，在每次任务切换最后都会更新PSP */</span><br><span class="hljs-keyword">str</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r2</span>]<br><br><span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r3</span>&#125;				<span class="hljs-comment">/* 将R3临时压入堆栈，R3保存了pxCurrentTCB地址，函数调用后会用到，因此要入栈保护 */</span><br><br><span class="hljs-comment">/* 关中断，中断优先级号大于等于configMAX_SYSCALL_INTERRUPT_PRIORITY的中断都会被屏蔽 */</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-symbol">#configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="hljs-keyword">msr</span> basepri, <span class="hljs-built_in">r0</span><br><br><span class="hljs-keyword">dsb</span>							<span class="hljs-comment">/* 数据同步隔离 */</span><br><span class="hljs-keyword">isb</span>							<span class="hljs-comment">/* 指令同步隔离 */</span><br><br><span class="hljs-keyword">bl</span> vTaskSwitchContext		<span class="hljs-comment">/* 切换到vTaskSwitchContext，查找下一个任务 */</span><br><br><span class="hljs-comment">/* 开中断 */</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0</span><br><span class="hljs-keyword">msr</span> basepri, <span class="hljs-built_in">r0</span><br><br><span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r3</span>&#125;				<span class="hljs-comment">/* 恢复R3，R3保存了pxCurrentTCB的地址，这里pxCurrentTCB的地址固定，但指向改变了 */</span><br><br><span class="hljs-comment">/* 当前激活的TCB栈顶值存入R0 */</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r3</span>]				<span class="hljs-comment">/* 将pxCurrentTCB指向的地址赋值给R1，即将TCB的首地址赋值给R1 */</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]				<span class="hljs-comment">/* 将R1地址所处的数据赋值给R0，即当前激活任务TCB的第一项的值赋给R0 */</span><br><br><span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">r0</span>!, &#123;<span class="hljs-built_in">r4</span>-<span class="hljs-built_in">r11</span>, <span class="hljs-built_in">r14</span>&#125;	<span class="hljs-comment">/* 将寄存器R4~R11出栈，并同时更新R0的值 */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 前两句判断是否使能了FPU，如果使能了，手动恢复s16-s31浮点寄存器</span><br><span class="hljs-comment"> * 其中s0~s15和FPSCR硬件自动完成</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">tst</span> <span class="hljs-built_in">r14</span>, <span class="hljs-number">#0x10</span><br><span class="hljs-keyword">it</span> eq<br><span class="hljs-symbol">vldmiaeq</span> <span class="hljs-built_in">r0</span>!, &#123;<span class="hljs-built_in">s16</span>-<span class="hljs-built_in">s31</span>&#125;<br><br><span class="hljs-keyword">msr</span> psp, <span class="hljs-built_in">r0</span>					<span class="hljs-comment">/* 将最新的任务堆栈栈顶赋值给线程堆栈指针PSP */</span><br><span class="hljs-keyword">isb</span>							<span class="hljs-comment">/* 指令同步隔离,清流水线 */</span><br><br><span class="hljs-comment">#ifdef WORKAROUND_PMU_CM001</span><br>	<span class="hljs-comment">#if WORKAROUND_PMU_CM001 == 1</span><br>		<span class="hljs-keyword">push</span> &#123; <span class="hljs-built_in">r14</span> &#125;<br>		<span class="hljs-keyword">pop</span> &#123; <span class="hljs-built_in">pc</span> &#125;<br>		<span class="hljs-keyword">nop</span><br>	<span class="hljs-comment">#endif</span><br><span class="hljs-comment">#endif</span><br><br><span class="hljs-keyword">bx</span> <span class="hljs-built_in">r14</span>	<span class="hljs-comment">/* 当调用 bx r14指令退出中断，堆栈指针PSP指向了新任务堆栈的正确位置 */</span><br><br></code></pre></td></tr></table></figure><br><br>  }<br><br>  说明：<br><br>  - 在Cortex-M处理器中有两个栈指针，一个是主栈指针(Main Stack Pointer，即MSP)，它可用于线程模式，在中断模式下只能用MSP；另一个是进程堆栈指针(Processor Stack Pointer，即PSP)，PSP总是用于线程模式。在任何时刻只能使用到其中一个。<br>  - 复位后处于线程模式特权级，默认使用MSP。在FreeRTOS中，MSP用于OS内核和异常处理，PSP用于应用任务。<br>  - 通过设置CONTROL寄存器的bit[1]选择使用哪个堆栈指针。CONTROL[1]&#x3D;0选择主堆栈指针；CONTROL[1]&#x3D;1选择进程堆栈指针。<br><br>  ### <strong>3.2 函数vTaskSwitchContext()</strong><br><br>  该函数会更新当前任务运行时间，检查任务堆栈使用是否溢出，然后调用宏 taskSELECT_HIGHEST_PRIORITY_TASK()获取更高优先级的任务。<br><br>  函数源代码如下：<br><br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vTaskSwitchContext</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/* 如果任务调度器已经挂起 */</span><br>	<span class="hljs-keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )<br>	&#123;<br>		xYieldPending = pdTRUE;		<span class="hljs-comment">/* 标记任务调度器挂起，不允许任务切换 */</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		xYieldPending = pdFALSE;	<span class="hljs-comment">/* 标记任务调度器没有挂起 */</span><br>	<span class="hljs-built_in">traceTASK_SWITCHED_OUT</span>();<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 如果启用运行时间统计功能，设置configGENERATE_RUN_TIME_STATS为1</span><br><span class="hljs-comment">	 * 如果使用了该功能，要提供以下两个宏：</span><br><span class="hljs-comment">	 * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()</span><br><span class="hljs-comment">	 * portGET_RUN_TIME_COUNTER_VALUE()</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span><br>	&#123;<br>			<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> portALT_GET_RUN_TIME_COUNTER_VALUE</span><br>				<span class="hljs-built_in">portALT_GET_RUN_TIME_COUNTER_VALUE</span>( ulTotalRunTime );<br>			<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>				ulTotalRunTime = <span class="hljs-built_in">portGET_RUN_TIME_COUNTER_VALUE</span>();<br>			<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * ulTotalRunTime记录系统的总运行时间，ulTaskSwitchedInTime记录任务切换的时间</span><br><span class="hljs-comment">			 * 如果系统节拍周期为1ms，则ulTotalRunTime要497天后才会溢出</span><br><span class="hljs-comment">			 * ulTotalRunTime &amp;lt; ulTaskSwitchedInTime表示可能溢出</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span>( ulTotalRunTime &amp;gt; ulTaskSwitchedInTime )<br>			&#123;<br>				<span class="hljs-comment">/* 记录当前任务的运行时间 */</span><br>				pxCurrentTCB-&amp;gt;ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-built_in">mtCOVERAGE_TEST_MARKER</span>();<br>			&#125;<br><br>			<span class="hljs-comment">/* 更新ulTaskSwitchedInTime，下个任务时间从这个值开始 */</span><br>			ulTaskSwitchedInTime = ulTotalRunTime;<br>	&#125;<br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configGENERATE_RUN_TIME_STATS */</span></span><br><br>	<span class="hljs-comment">/* 核查堆栈是否溢出 */</span><br>	<span class="hljs-built_in">taskCHECK_FOR_STACK_OVERFLOW</span>();<br><br>	<span class="hljs-comment">/* 寻找更高优先级的任务 */</span><br>	<span class="hljs-built_in">taskSELECT_HIGHEST_PRIORITY_TASK</span>();<br><br>	<span class="hljs-built_in">traceTASK_SWITCHED_IN</span>();<br><br>	<span class="hljs-comment">/* 如果使用Newlib运行库，你的操作系统资源不够，而不得不选择newlib，就必须打开该宏 */</span><br>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span><br>	&#123;<br>		_impure_ptr = &amp;amp;( pxCurrentTCB-&amp;gt;xNewLib_reent );<br>	&#125;<br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_NEWLIB_REENTRANT */</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><br><br>  }<br><br>  ### <strong>3.2 寻找下一个任务的方式</strong><br><br>  PendSV中会调用vTaskSwitchContext()，最后调用函数taskSELECT_HIGHEST_PRIORITY_TASK()寻找优先级最高的任务。<br><br>  对于FreeRTOS的调度器，它有两种方式寻找下一个最高优先级的任务，分别为特殊方式和常用方式，在FreeRTOSConfig.h中可通过宏定义设置，如下：<br><br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 0：使用常用方式来选择下一个要运行的任务；1：使用特殊方法来选择下一个要运行的任务 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION	1</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><br><br>  在FreeRTOS中，通用方法不依赖某些硬件等限制，适用于多种MCU中。特殊方式是使用了某些硬件的特性，只针对部分MCU而使用。<br><br>  ### <strong>3.2.1 常用方法</strong><br><br>  uxTopReadyPriority 记录就绪态中最高优先级值，创建任务时会更新值，有任务添加到就绪表时也会更新值。这种方法对任务的数量无限制。<br><br>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define taskSELECT_HIGHEST_PRIORITY_TASK()												\</span><br>&#123;																						<span class="hljs-string">\</span><br>	UBaseType_t uxTopPriority = uxTopReadyPriority;										<span class="hljs-string">\</span><br>																						<span class="hljs-string">\</span><br>	<span class="hljs-keyword">while</span>( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) )				<span class="hljs-string">\</span><br>	&#123;																					<span class="hljs-string">\</span><br>		configASSERT( uxTopPriority );													<span class="hljs-string">\</span><br>		--uxTopPriority;																<span class="hljs-string">\</span><br>	&#125;																					<span class="hljs-string">\</span><br>																						<span class="hljs-string">\</span><br>	<span class="hljs-comment">/* 获取优先级最高任务的任务控制块 */</span>														<span class="hljs-string">\</span><br>	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );<span class="hljs-string">\</span><br>uxTopReadyPriority = uxTopPriority;	 												<span class="hljs-string">\</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br><br>  }<br><br>  ### <strong>3.2.2 特殊方式</strong><br><br>  使用此方法，uxTopReadyPriority 每个bit位表示一个优先级，bit0表示优先级0，bit31表示优先级31，使用此方式优先级最大只能是32个。<br><br>  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define taskSELECT_HIGHEST_PRIORITY_TASK()														\</span><br>&#123;																								<span class="hljs-string">\</span><br>	UBaseType_t uxTopPriority;																		<span class="hljs-string">\</span><br>																								<span class="hljs-string">\</span><br>	<span class="hljs-comment">/* 获取优先级最高的任务 */</span>								<span class="hljs-string">\</span><br>	portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								<span class="hljs-string">\</span><br>	configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; <span class="hljs-number">0</span> );		<span class="hljs-string">\</span><br><span class="hljs-comment">/* 获取优先级最高任务的任务控制块 */</span><br>listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;amp;( pxReadyTasksLists[ uxTopPriority ] ) );		<span class="hljs-string">\</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><br><br>  }<br><br>  其中：<br><br>  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define portGET_HIGHEST_PRIORITY( <span class="hljs-name">uxTopPriority</span>, uxReadyPriorities ) uxTopPriority = ( <span class="hljs-number">31</span>UL - ( <span class="hljs-name">uint32_t</span> ) __clz( ( <span class="hljs-name">uxReadyPriorities</span> ) ) )<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br><br>  __clz( ( uxReadyPriorities ) 是计算uxReadyPriorities 的前导零个数，如：<br><br>  二进制0001 1010 0101 1111的前导零个数为3，可以知道，最高优先级uxTopPriority 等于 31减去前导零个数。<br><br>  知道最高优先级的优先级，则通过listGET_OWNER_OF_NEXT_ENTRY()对应最高优先级的列表项，将pxCurrentTCB指向对应的控制块。
  </h2><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h3><p>  【1】: 正点原子:《STM32F407 FreeRTOS开发手册V1.1》</p>
<p>  【2】: 野火:《FreeRTOS 内核实现与应用开发实战指南》</p>
<p>  【3】: 《Cortex M3权威指南(中文)》</p>
</li>
<li><p>总结</p>
</li>
</ul>
</li>
<li><p>任务切换原理详解文章总结：</p>
<ul>
<li><p>Newbing给的PendSVHandler伪代码：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取当前任务的TCB指针</span><br>    r0 = psp;<br>    r3 = pxCurrentTCB;<br>    r2 = *r3;<br><br>    <span class="hljs-comment">// 保存当前任务的上下文到堆栈中</span><br>    stmdb r0!, &#123;r4-r11&#125;;<br>    str r0, [r2];<br><br>    <span class="hljs-comment">// 调用vTaskSwitchContext函数，获取下一个要运行的任务</span><br>    bl vTaskSwitchContext;<br>    r1 = *r3;<br><br>    <span class="hljs-comment">// 从新任务的堆栈中恢复上下文</span><br>    ldr r0, [r1];<br>    ldmia r0!, &#123;r4-r11&#125;;<br>    msr psp, r0;<br><br>    <span class="hljs-comment">// 返回到新任务的用户程序</span><br>    bx lr;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>  PendSV中断服务函数都做了什么：</p>
<p>  首先要明白什么是任务的上下文：一个任务运行时，ARM通用寄存器组的值是特定的，每一个任务有自己的寄存器值，相当于读一本书，书某个章节的背景，如果没有这个故事背景，就无法理解这个章节在讲什么(执行异常)；</p>
<p>  然后就是看一下PendSV的伪代码；假设现在低优先级任务要切换到高优先级任务执行，①低优先级的上下文被保存到自己的任务栈中(每一个任务在创建时都会分配自己的栈，所以用的不是系统栈，系统栈是给中断&#x2F;异常使用的)，②然后调用 switch_context函数找当前就绪链表中优先级最高的任务，将pxCurrentTCB指向这个最高优先级任务。③最后回到PendSVHandler，将新任务的上下文恢复，继续运行；
  </p>
</li>
<li><p>STM32 FreeRTOS 优先级翻转？优先级继承？【动态静态优先级继承】</p>
<h3 id="指路→"><a href="#指路→" class="headerlink" title="指路→"></a><a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-STM32HAL-8-14-22d01922723e441a970d342ac41f20f9?pvs=21">指路→</a></h3><p>  简单来说，比如三个任务高中低优先级，低和高优先级任务都要获取同一个二值信号量；</p>
<p>  中高优先级延时一段时间先让低优先级运行；</p>
<p>  低优先级获取二值信号量后，中优先级延时结束，突然抢了低优先级的CPU控制权进入长时间的循环，不释放CPU控制权，此时高优先级的任务就没法执行，即进入优先级翻转状态。</p>
<p>  （中优先级一直在运行，高优先级没法运行）</p>
<p>  危害：高优先级任务无法运行，系统实时性受影响；</p>
<p>  优先级继承，——&gt;</p>
<p>  FreeRTOS中的优先级继承机制是一种解决优先级反转问题的方法，它可以让一个低优先级的任务在获取了一个互斥量后，临时继承一个高优先级任务的优先级，从而避免被中间优先级的任务抢占，导致高优先级任务无法及时获取互斥量而阻塞。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sty124578/article/details/80534276">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/fdfdsds/article/details/87900983">2</a></p>
<p>  优先级反转是指当一个高优先级的任务需要等待一个低优先级的任务释放一个资源时，如果有一个中间优先级的任务抢占了低优先级的任务，那么高优先级的任务就会被反转地无限期地等待，从而影响系统的实时性和稳定性。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/FreeRTOS">3</a></p>
<p>  FreeRTOS中实现了两种优先级继承机制：静态优先级继承和动态优先级继承。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sty124578/article/details/80534276">1</a></p>
<p>  静态优先级继承是指在<strong>创建互斥量时</strong>，<strong>就指定了一个最高可继承的优先级</strong>，当一个低优先级的任务获取了这个互斥量后，它会自动提升到这个最高可继承的优先级，直到释放了互斥量后恢复原来的优先级。这种方式简单易用，但是可能会导致不必要的优先级提升或者仍然发生优先级反转。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sty124578/article/details/80534276">1</a></p>
<p>  动态优先级继承是指在创建互斥量时，不指定任何最高可继承的优先级，当一个低优先级的任务获取了这个互斥量后，<strong>它会根据当前等待这个互斥量的最高优先级的任务来动态调整自己的优先级，从而保证自己总是比等待者高一点</strong>。这种方式更加灵活和有效，但是也更加复杂和耗时。<a target="_blank" rel="noopener" href="https://blog.csdn.net/sty124578/article/details/80534276">1</a></p>
<p>  FreeRTOS提供了一些函数和宏来实现和控制优先级继承机制，例如：</p>
<ul>
<li><code>xSemaphoreCreateMutex()</code> 和 <code>xSemaphoreCreateRecursiveMutex()</code> 用于创建支持静态优先级继承的互斥量。</li>
<li><code>xSemaphoreCreateMutexStatic()</code> 和 <code>xSemaphoreCreateRecursiveMutexStatic()</code> 用于创建支持静态优先级继承的互斥量，并使用静态内存分配。</li>
<li><code>xQueueCreateMutex()</code> 和 <code>xQueueCreateRecursiveMutex()</code> 用于创建支持动态优先级继承的互斥量。</li>
<li><code>xQueueCreateMutexStatic()</code> 和 <code>xQueueCreateRecursiveMutexStatic()</code> 用于创建支持动态优先级继承的互斥量，并使用静态内存分配。</li>
<li><code>xTaskPriorityDisinherit()</code> 用于取消一个任务对互斥量的优先级继承。</li>
<li><code>configUSE_MUTEXES</code> 宏用于使能或禁止静态优先级继承机制。</li>
<li><code>configUSE_RECURSIVE_MUTEXES</code> 宏用于使能或禁止递归互斥量。</li>
<li><code>configUSE_APPLICATION_TASK_TAG</code> 宏用于使能或禁止动态优先级继承机制。</li>
</ul>
<p>  如果你想了解更多关于FreeRTOS中的优先级继承机制，你可以参考以下链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sty124578/article/details/80534276">FreeRTOS - 任务管理</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/FreeRTOS">FreeRTOS - 維基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fdfdsds/article/details/87900983">FreeRTOS-优先级继承机制-学习笔记</a></li>
</ul>
</li>
<li><p>FreeRTOS空闲任务？</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">指路——&gt;</a></p>
</li>
<li><p>FreeRTOS优先级最大是多少？为什么?</p>
<p>  32;   【当然也会因为硬件平台的不同而不同】</p>
<p>  但是定义 <strong>configUSE_PORT_OPTIMISED_TASK_SELECTION</strong> 这个需要注意一点，它不能够支持优先级的个数超过 32 个，因为 CLZ 最大就处理 32 bit，所以这个表示优先级的 bitmap 最多 32，也就是优先级限定在 32 个以内；</p>
<p>  CLZ指令是什么？——这个指令用来计算一个变量从最高位开始的连续零的个数，以此获得优先级最高的任务；</p>
</li>
<li><p>任务的组成？—— 任务堆栈，任务TCB，任务代码；<a target="_blank" rel="noopener" href="https://www.notion.so/STM32_HAL-2023-10-15-996797e72af14652b327f262d8b0ad9f?pvs=21">任务堆栈解析——&gt;</a></p>
<p>  uCOS操作系统</p>
<p>  从存储结构上看，任务是如何组成的?</p>
<p>  答：从存储结构上看，任务由任务控制块、任务堆栈、任务代码三个部分组成。系统通过任务控制块感知和控制任务；任务堆栈主要用于保护断点和恢复断点；任务代码是一个超循环结构，描述了任务的执行过程。在创建一个任务时，函数OSTaskCreate()或OSTaskCreateExt()负责给任务分配任务控制块和任务堆栈，并对他们进行初始化，然后将任务控制块、任务堆栈、任务代码三者关联起来形成一个完整的任务。</p>
</li>
<li><p>什么是可剥夺型内核？不可剥夺型内核？——它们主要区别在于内核态的进程或线程是否可以被中断或抢占。</p>
<p>  可剥夺型内核和不可剥夺型内核是两种不同的操作系统内核设计，它们主要区别在于内核态的进程或线程是否可以被中断或抢占。</p>
<ul>
<li>可剥夺型内核是指内核态的进程或线程可以被其他更高优先级的进程或线程中断或<strong>抢占</strong>，从而实现多任务的<strong>并发执行</strong>。可剥夺型内核的优点是可以提高系统的响应性和实时性，缩短用户等待时间，提高资源利用率。可剥夺型内核的缺点是需要处理内核态的同步和互斥问题，增加了系统的复杂性和开销。</li>
<li>不可剥夺型内核是指内核态的进程或线程不可以被其他任何进程或线程中断或抢占，只有在<strong>自愿放弃CPU或者执行完毕</strong>后才会切换到其他任务。不可剥夺型内核的优点是简化了内核态的设计和实现，<strong>避免了死锁和竞争条件等问题</strong>。不可剥夺型内核的缺点是<strong>降低了系统的响应性和实时性，增加了用户等待时间</strong>，浪费了资源。</li>
</ul>
<p>  一般来说，可剥夺型内核适合用于需要高度并发和实时性的系统，例如嵌入式系统、实时操作系统等。不可剥夺型内核适合用于需要简单和稳定的系统，例如单用户单任务的系统、批处理系统等。
  </p>
</li>
<li><p>什么是可重入函数？</p>
<p>  可以被多个任务调用的函数，而不必担心数据的破坏。</p>
</li>
<li><p>上下文是什么？【0925】FreeRTOS的上下文就是ARM的15个寄存器还有任务堆栈，把任务的堆栈指针压入栈中进行上下文切换（此处注意，一个任务的堆栈也是在内存芯片那一块地方里面，要在下次切换回这个任务，就要找到这一块地方的地址，任务TCB中包含任务堆栈指针，所以切换时要保存这个指针的内容以便下次切换回到原处）</p>
<p>  上下文是指任务在运行时所需要的所有信息，包括寄存器、堆栈、优先级等。上下文的保存和恢复是实现任务切换的关键步骤，它们可以保证任务在被中断和恢复时，能够继续执行正确的逻辑。</p>
</li>
<li><p>动态创建任务和静态创建任务的区别？——动态在堆上分配(运行时分配)；静态直接在全局分配空间(编译时决定)，删除任务则该处的内存无法再使用；</p>
<h2 id="动态创建最终也会调用静态创建的过程。-本质是资源的分配方式是动态还是静态的，资源包括任务栈空间以及一些任务结构体内容。-静态创建即把需要的存储空间通过全局变量定义分配，创建的过程是对这些资源的使用。-动态创建是通过动态内存分配接口申请出需要的内存空间，这时你可以认为到了和静态创建相同的起点，资源已经准备好了，接下来对资源的使用是相同的，公共的。-动态创建人如其名，实现比较灵活，可以创建也可以释放相应的内存空间，是在运行时动态控制的。-静态创建的资源是在编译阶段决定的，之后无法释放，这片空间你用或者不用他都在哪里。"><a href="#动态创建最终也会调用静态创建的过程。-本质是资源的分配方式是动态还是静态的，资源包括任务栈空间以及一些任务结构体内容。-静态创建即把需要的存储空间通过全局变量定义分配，创建的过程是对这些资源的使用。-动态创建是通过动态内存分配接口申请出需要的内存空间，这时你可以认为到了和静态创建相同的起点，资源已经准备好了，接下来对资源的使用是相同的，公共的。-动态创建人如其名，实现比较灵活，可以创建也可以释放相应的内存空间，是在运行时动态控制的。-静态创建的资源是在编译阶段决定的，之后无法释放，这片空间你用或者不用他都在哪里。" class="headerlink" title="  动态创建最终也会调用静态创建的过程。  本质是资源的分配方式是动态还是静态的，资源包括任务栈空间以及一些任务结构体内容。  静态创建即把需要的存储空间通过全局变量定义分配，创建的过程是对这些资源的使用。  动态创建是通过动态内存分配接口申请出需要的内存空间，这时你可以认为到了和静态创建相同的起点，资源已经准备好了，接下来对资源的使用是相同的，公共的。  动态创建人如其名，实现比较灵活，可以创建也可以释放相应的内存空间，是在运行时动态控制的。  静态创建的资源是在编译阶段决定的，之后无法释放，这片空间你用或者不用他都在哪里。
  "></a>  动态创建最终也会调用静态创建的过程。<br><br>  本质是资源的分配方式是动态还是静态的，资源包括任务栈空间以及一些任务结构体内容。<br><br>  静态创建即把需要的存储空间通过全局变量定义分配，创建的过程是对这些资源的使用。<br><br>  动态创建是通过动态内存分配接口申请出需要的内存空间，这时你可以认为到了和静态创建相同的起点，资源已经准备好了，接下来对资源的使用是相同的，公共的。<br><br>  动态创建人如其名，实现比较灵活，可以创建也可以释放相应的内存空间，是在运行时动态控制的。<br><br>  静态创建的资源是在编译阶段决定的，之后无法释放，这片空间你用或者不用他都在哪里。
  </h2><p>  动态创建的任务使用的栈和任务控制块是在建立任务的时候FreeRTOS 动态分配的。</p>
<p>  静态创建任务使用的栈和任务控制块是预先定义好的全局变量。</p>
<p>  动态创建的优点是在任务建立的时候使用动态分配内存按需分配内存，随用随取，任务建立函数会返回一个指针，用于指向任务控制块，因此要预先为任务栈定义一个任务控制块指针。动态的缺点可能会因为内存不足导致创建任务失败，也就是多个任务malloc但是没有free掉，导致可能其他任务创建任务分配失败。</p>
<p>  静态的优点是稳定，内存足够分配，缺点是耗内存！任务删除以后这段内存没法释放掉，就只能浪费掉。</p>
</li>
<li><p>临界区、临界资源、<strong>临界资源保护</strong>；原子性、原子操作：</p>
<p>  临界区：访问公共资源(全局变量)的代码片段；</p>
<p>  临界资源：会被多任务访问的资源；</p>
<p>  原子性：一次执行到底，全部执行的，不能被其他代码打断的；</p>
<p>  临界区、临界资源<br>  临界区：是指一个访问共用资源的程序片段。共用资源称为临界资源。<br>  临界资源：具有无法同时被多个线程(比如多任务,比如中断服务程序)访问的特性，一次只能供一个线程使用。例如：共用的设备或存储器。打印机；中断服务程序与其他程序、中断与任务、任务与任务共享的变量等。</p>
<p>  原子操作、原子性、原子<br>  原子：指化学反应不可再分的基本微粒。这是物理化学中的概念，原子基本特性就是不可分割性。<br>  原子性：指事务的<strong>不可分割性</strong>，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行。<br>  原子操作：是指一系列不能被打断的操作。可以是一个步骤的操作，也可以是多个步骤的操作。原子操作依赖底层CPU实现。原子操作与临界区是密切相关的，可以说原子操作就是临界区引发出来的需求。</p>
<p>  临界资源的保护</p>
<p>  临界资源保护的核心就是在临界资源竞争中，让其不被破坏。为达到不被破坏目的，那就让临界资源一次只能供一个线程使用。能实现这样效果的立马会想到开关中断，开停调度器等。</p>
<p>  <strong>像在FreeRTO临界段的实现就是用开关中断实现的。</strong></p>
</li>
<li><p>RTOS通信部分一定要多研究研究 ，没有Linux经历的话 什么消息队列 二值信号量 的实现方法</p>
</li>
<li><p>看群友消息记录知道的 FreeRTOS、UCOS、RTT：</p>
<p>  相比FreeRTOS，RTT的框架更完善功能更多，代码风格差别也大，RTT的代码风格更好。FreeRTOS的栈溢出的处理不太好。RTT有栈回溯【？啥玩意】</p>
</li>
<li><p>FreeRTOS移植主要的点：<a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-STM32HAL-8-14-22d01922723e441a970d342ac41f20f9?pvs=21">【0925】移植——》</a></p>
<h1 id="1-移植"><a href="#1-移植" class="headerlink" title="1. 移植"></a><strong>1. 移植</strong></h1><ul>
<li>添加src文件，添加包含路径</li>
<li>修改FreeRTOSconfig.h<ul>
<li><p>定义中断组：</p>
<p>  4</p>
</li>
<li><p>宏定义<strong>SVC，PendSV，SysTick</strong>中断处理函数</p>
</li>
<li><p>根据所需功能，裁剪系统</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>FreeRTOS与Cortex-M3 STM32 中断的管理：</p>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219/%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%20%E3%80%90STM32%E3%80%91FreeRTOS%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE_51CTO%E5%8D%9A%E5%AE%A2_stm32%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%20ec37675e201c4bffa7d5bbdee332ae3b.md">参考文章:<strong>【STM32】FreeRTOS中断配置_51CTO博客_stm32串口空闲中断</strong></a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.51cto.com/dlican/5108397">https://blog.51cto.com/dlican/5108397</a><strong>【STM32】FreeRTOS中断配置</strong></p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">stm32 Cortex-m3 异常、中断表</a>：记住内核异常： -3 Reset 复位中断； -2 NMI 外部中断输入 不可屏蔽中断； -1 Hard_Fault 硬件错误(时钟错误等)</p>
<ul>
<li><p>STM32中断优先级只有16个，0~15；但是Cortex-M3内核有256个中断(包含内核异常)；但是MCU厂商会自己决定使用多少位，有多少个中断优先级；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2066.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>STM32中会触发Hard_Fault的因素：<a target="_blank" rel="noopener" href="https://max.book118.com/html/2017/0527/109656283.shtm">https://max.book118.com/html/2017/0527/109656283.shtm</a></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2067.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>PRIMASK  &amp;  FULLMASK 都是直接屏蔽除了Reset中断、NMI中断、HardFault中断的其他中断，只需要将寄存器的值置1即可</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2068.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>而FreeRTOS中的关中断使用的是 basepri 寄存器；写入0不屏蔽；写入数值则屏蔽优先级大于该数的中断</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2069.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2070.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>FreeRTOS中的锁：<strong>中断锁、调度锁、互斥锁、</strong>任务锁；及其原理</p>
<ul>
<li><p>参考：</p>
<p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Liu-Jing/p/7244235.html">https://www.cnblogs.com/Liu-Jing/p/7244235.html</a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26226375/article/details/123955528">https://blog.csdn.net/qq_26226375&#x2F;article&#x2F;details&#x2F;123955528</a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26226375/article/details/123886654?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_26226375&#x2F;article&#x2F;details&#x2F;123886654?spm&#x3D;1001.2014.3001.5501</a></p>
</li>
</ul>
<p>  <strong>调度锁</strong>：禁止 任务切换；跟临界段要分清楚，任务调度锁不能禁止中断！</p>
<ul>
<li><p>调度锁原理：</p>
<p>  调度锁函数</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">vTaskSuspendAll( <span class="hljs-type">void</span> ) 开启调度锁（不允许调度）<br> <br>xTaskResumeAll(<span class="hljs-type">void</span>) 关闭调度锁（允许调度）<br></code></pre></td></tr></table></figure>
<p>  该函数原理：只是简单把 uxSchedulerSuspended + 1</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspendAll</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* A critical section is not required as the variable is of type</span><br><span class="hljs-comment">BaseType_t.  Please read Richard Barry&#x27;s reply in the following link to a</span><br><span class="hljs-comment">post in the FreeRTOS support forum before reporting this as a bug! -</span><br><span class="hljs-comment">http://goo.gl/wu4acr */</span><br>++uxSchedulerSuspended;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  在 SwitchContext函数中会检查这个参数是否置1：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSwitchContext</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )<br>&#123;<br><span class="hljs-comment">/* The scheduler is currently suspended - do not allow a context</span><br><span class="hljs-comment">switch. */</span><br>xYieldPending = pdTRUE;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>  <strong>中断锁</strong>：禁止中断触发，同时禁止了SystickHandler和PendSVHandler，也禁止了任务切换；</p>
<ul>
<li><p>中断锁代码：</p>
<p>  #define portDISABLE_INTERRUPTS() vPortRaiseBASEPRI() &#x2F;&#x2F;进临界区<br>  #define portENABLE_INTERRUPTS() vPortSetBASEPRI( 0 ) &#x2F;&#x2F;退出临界区</p>
<p>  #define <strong>portENTER_CRITICAL</strong>() vPortEnterCritical()&#x2F;&#x2F;进临界区<br>  #define <strong>portEXIT_CRITICAL</strong>() vPortExitCritical()&#x2F;&#x2F;退出临界区</p>
<p>  #define portSET_INTERRUPT_MASK_<strong>FROM_ISR</strong>() ulPortRaiseBASEPRI()&#x2F;&#x2F;进临界区<br>  #define portCLEAR_INTERRUPT_MASK_<strong>FROM_ISR</strong>(x) vPortSetBASEPRI(x)&#x2F;&#x2F;退出临界区</p>
</li>
</ul>
<p>  <strong>互斥锁</strong>：访问临界资源用；谁用谁释放；Mutex；
  </p>
</li>
<li><p>【0920】很烦的一个问题：ISR和不带ISR的函数有什么区别？——ISR函数会立即返回不会阻塞；<strong>ISR不是任务，不能进入阻塞状态；</strong>如果两种API混杂在一起会导致代码复杂度高，移植困难；</p>
<p>  好好看韦东山老师的文章——&gt;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/439113270">韦东山freeRTOS系列教程之【第十一章】中断管理(Interrupt Management) - 知乎 (zhihu.com)</a></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2071.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【0920】 Heap _1 _2 _3 _4 _5 作用的简单描述：</p>
<p>  Heap_124都是使用一整个大数组来分配内存；</p>
<p>  _1的特性 申请之后没法释放；</p>
<p>  _2能够释放，使用最佳匹配算法来分配内存，也就是要找到最合适的那一块内存进行分配，多出来的就留给之后的pvPortMalloc使用；</p>
<p>  _3 完全是使用C语言的API malloc 和 free， 跟FreeRTOS特性无关；</p>
<p>  _4 可以释放内存，且使用的是首次适应算法，也就是直接获取当前查询到最大的内存进行分配，多出来的留给之后的申请使用。</p>
<p>  _5 在4的基础上进行优化，分配的内存不是基于大数组，而是分散的内存；用一个数组来表示剩余的内存空间地址以及其大小；</p>
</li>
<li><p>【0925】在做基于STM32的FREERTOS应用中出现比较频繁的问题是什么？</p>
<p>  应属STACK溢出和中断优先级相关的问题。</p>
</li>
<li><p>【0925】<strong>最频繁的问题！！！</strong>FreeRTOS堆栈溢出检测：</p>
<ul>
<li><p>参考：strongerHuang大佬</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/ybhuangfugui/article/details/120897699">https://blog.csdn.net/ybhuangfugui/article/details/120897699</a></p>
</li>
</ul>
</li>
<li><p>【1007】idle任务如何释放被删除任务空间的？<strong>prvCheckTasksWaitingTermination</strong></p>
<p>  使用了一个链表把被删除的任务加进去，然后IDLE执行的时候会查这个链表 然后释放其空间；</p>
<p>  task.c → static <strong>portTASK_FUNCTION</strong>( <strong>prvIdleTask</strong>, pvParameters ) → <strong>prvCheckTasksWaitingTermination</strong></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvCheckTasksWaitingTermination</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><br>	<span class="hljs-comment">/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/</span><br><br>	<span class="hljs-meta">#<span class="hljs-keyword">if</span> ( INCLUDE_vTaskDelete == 1 )</span><br>	&#123;<br>		BaseType_t xListIsEmpty;<br><br>		<span class="hljs-comment">/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called</span><br><span class="hljs-comment">		too often in the idle task. */</span><br>		<span class="hljs-keyword">while</span>( uxDeletedTasksWaitingCleanUp &gt; ( UBaseType_t ) <span class="hljs-number">0U</span> )<br>		&#123;<br>			vTaskSuspendAll();<br>			&#123;<br>				xListIsEmpty = listLIST_IS_EMPTY( &amp;xTasksWaitingTermination );<br>			&#125;<br>			( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br>			<span class="hljs-keyword">if</span>( xListIsEmpty == pdFALSE )<br>			&#123;<br>				TCB_t *pxTCB;<br><br>				taskENTER_CRITICAL();<br>				&#123;<br>					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &amp;xTasksWaitingTermination ) );<br>					( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) );<br>					--uxCurrentNumberOfTasks;<br>					--uxDeletedTasksWaitingCleanUp;<br>				&#125;<br>				taskEXIT_CRITICAL();<br><br>				prvDeleteTCB( pxTCB );<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				mtCOVERAGE_TEST_MARKER();<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* INCLUDE_vTaskDelete */</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="FreeRTOS2"><a href="#FreeRTOS2" class="headerlink" title="FreeRTOS2"></a>FreeRTOS2</h2><ul>
<li><p>这两篇文章的问题学明白了也差不都了：</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012294613/article/details/130916345">https://blog.csdn.net/u012294613/article/details/130916345</a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012294613/article/details/130916372">https://blog.csdn.net/u012294613/article/details/130916372</a></p>
</li>
<li><p>问题大纲 【非常非常重要 五星重要】</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FreeRTOS<br>主要是系统方面的，人家会问你移植的东西具体怎么移植的。<br>freertos的有关中断发生，处理，嵌套方面的<br>说下中断和轮询？<br>框架性回答一个嵌入式系统启动到结束的过程？<br>Freertos怎么学的？<br>除了任务切换对freertos其他底层了解吗？<br>任务切换的原理？<br>讲讲freertos任务调度的原理<br>如何实现一个队列？<br>说下互斥锁和条件变量？<br>说下二值信号量与互斥信号量的区别？<br>介绍实习项目的架构、freertos的应用？<br>switch_context的底层原理 （freertos）？<br>讲了下切换的场景，pendsv函数的实现，switch_context里面关于pcb_current指针的逻辑等？<br><br>uCOS<br>Ucos操作系统 你认为最重要的是什么？<br>ucos任务如何调度，最多有多少个任务。<br>对ucos操作系统的理解，能不能独立实现简单的任务切换功能<br><br>RTOS常见面试问题<br>RTOS的实时性是如何实现的<br>任务之间是如何通信的<br>二值信号量和互斥量的区别<br>任务通知是怎么是实现的<br>RTOS内核是怎么调度的<br>FreeRTOS四种任务状态<br></code></pre></td></tr></table></figure>
</li>
<li><p>【DJI】RTOS的实时性是如何实现的？</p>
<p>  使用调度器；FreeRTOS调度器严格按照任务优先级来分配CPU时间；(但是时间片不是必选项，没有时间片时，一个优先级只能有一个任务)；</p>
<p>  有三种调度方式：抢占式调度；时间片调度；合作式调度；</p>
</li>
<li><p>【0925】FreeRTOS和Systick</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.notion.so/STM32_HAL-2023-10-15-996797e72af14652b327f262d8b0ad9f?pvs=21">以前写的很详细的Systick解析——&gt;</a> 包括为什么要使用Systick，为什么Systick设置为最低优先级</li>
</ul>
<p>  然后今天写的是FreeRTOS如何关联Systick和Systick_Handler：</p>
<ul>
<li><p>首先是ChatGPT：FreeRTOS是如何与Systick_Handler关联的？能不能给出具体的代码？</p>
<p>  FreeRTOS是一个实时操作系统，它使用Systick作为自己的时钟源，用于产生周期性的嘀嗒信号，用于时间片调度和延时函数等。FreeRTOS与Systick_Handler的关联是通过以下几个步骤实现的：</p>
<ul>
<li>在FreeRTOSConfig.h文件中，定义了一个宏xPortSysTickHandler，将其映射为SysTick_Handler。这样，当Systick中断发生时，就会调用xPortSysTickHandler函数。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47713364/article/details/119578800">1</a></li>
<li>在port.c文件中，实现了xPortSysTickHandler函数，它是一个弱符号（__weak），可以被用户重写。这个函数的作用是在每个Systick中断中调用xTaskIncrementTick函数，用于增加系统时钟计数，并判断是否需要进行任务切换。如果需要任务切换，就会触发PendSV异常，用于保存和恢复任务的上下文。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/551096072">2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/szbird123/article/details/78110855">3</a></li>
<li>在port.c文件中，还实现了vPortSetupTimerInterrupt函数，它是一个弱符号（__weak），可以被用户重写。这个函数的作用是在启动任务调度器时对Systick进行初始化和配置，设置其重装载值、控制寄存器和优先级等。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33938558/article/details/107886329">4</a></li>
</ul>
<p>  以下是一些相关的代码片段：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在FreeRTOSConfig.h文件中</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortSysTickHandler SysTick_Handler</span><br><br><span class="hljs-comment">// 在port.c文件中</span><br>__weak <span class="hljs-type">void</span> <span class="hljs-title function_">vPortSetupTimerInterrupt</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* Configure SysTick to interrupt at the requested rate. */</span><br>    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - <span class="hljs-number">1UL</span>;<br>    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );<br>&#125;<br><br>__weak <span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* Increment the RTOS tick. */</span><br>    <span class="hljs-keyword">if</span>( xTaskIncrementTick() != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* A context switch is required. Context switching is performed in</span><br><span class="hljs-comment">        the PendSV interrupt. Pend the PendSV interrupt. */</span><br>        portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>解释AI的回答：定义了一个宏xPortSysTickHandler，将其映射为SysTick_Handler；</p>
<p>  也就是 #define <strong>xPortSysTickHandler</strong> SysTick_Handler </p>
<p>  这一句宏定义；。。。首先要记得，编译的时候会把宏展开，也就是写的 <strong>xPortSysTickHandler</strong> 会被替换成SysTick_Handler ，这样 注释掉stm32f1xx_it.c中的SysTick_Handler之后还是可以调用，只不过换了个名字而已，最后编译出来的还是SysTick_Handler。</p>
</li>
<li><p>总结AI的回答：#define xPortSysTickHandler SysTick_Handler</p>
</li>
<li><p>补充AI的回答：在vTaskStartScheduler 启动任务调度器之时，同样也会初始化Systick；注意是Systick！！内核定时器；而且直接写的寄存器；在文件 port.c 中实现的<code>vPortSetupTimerInterrupt</code> 函数；</p>
<ul>
<li><p>参考：</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_47713364/article/details/119578800">https://blog.csdn.net/qq_47713364&#x2F;article&#x2F;details&#x2F;119578800</a></p>
</li>
</ul>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219/%E3%80%90STM32%20FreeRTOS%E3%80%91SysTick%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8F%8AFreeRTOS%E7%B3%BB%E7%BB%9F%E8%8A%82%E6%8B%8D%2043a7e9735f5a4789bb98fd321b7b8c3a.md"><strong><strong>【STM32&#x2F;FreeRTOS】SysTick定时器及FreeRTOS系统节拍</strong></strong></a></p>
<p>  看Systick寄存器定义的话可以点进去看看，但是关键就在于下面这一段代码：</p>
<p>  直接配置了寄存器：</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx">#<span class="hljs-keyword">if</span> configOVERRIDE_DEFAULT_TICK_CONFIGURATION == <span class="hljs-number">0</span><br><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">vPortSetupTimerInterrupt</span>(<span class="hljs-params"> <span class="hljs-keyword">void</span> </span>)<br>	&#123;<br>		<span class="hljs-comment">/* Calculate the constants required to configure the tick interrupt. */</span><br>		#<span class="hljs-keyword">if</span> configUSE_TICKLESS_IDLE == <span class="hljs-number">1</span><br>		&#123;<br>			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );<br>			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;<br>			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );<br>		&#125;<br>		#endif <span class="hljs-comment">/* configUSE_TICKLESS_IDLE */</span><br><br>		<span class="hljs-comment">/* Configure SysTick to interrupt at the requested rate. */</span><br>		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;<br>		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );<br>	&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>【0925】绝对延时图解：</p>
<p>  <strong>（3）freeRTOS的延时函数</strong></p>
<p>  <strong>1）相对延时函数</strong></p>
<p>  <code>void vTaskDelay(const TickType_t TicksToDelay)   • 1.</code></p>
<p>  <strong>2）绝对延时函数</strong></p>
<p>  <code>void vTaskDelayUntil (                                     TickType_t* const pxPreviousWakeTime,                                      const TickType_t xTimeIncrement                                    )</code><br>  绝对延时函数的运行大致过程如下示意图：</p>
<p>  <img src="https://s2.51cto.com/images/blog/202211/13105135_63705bb74f1b356639.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=,x-oss-process=image/resize,m_fixed,w_1184/format,webp" srcset="/img/loading.gif" lazyload alt="https://s2.51cto.com/images/blog/202211/13105135_63705bb74f1b356639.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=,x-oss-process=image/resize,m_fixed,w_1184/format,webp"></p>
<p>  <strong>注意：相对延时函数和绝对延时函数的调用都会引起系统的任务切换，并且相对延时函数不是精确的延时函数，绝对延时函数才是精确的延时调度。</strong></p>
<p>  <strong>如果在代码中，有某一部分的功能需要固定时间被执行的话，在优先级较高的时候，可以考虑使用绝对延时实现。</strong></p>
</li>
<li><p>二值信号量和互斥信号量的区别：【互斥信号量只能由获取的任务释放；二值信号量可以由其他任务释放；所以二值更适用于同步】</p>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219.md">额外——同步、互斥的区别——&gt;</a></p>
<p>  二值信号量没有优先级继承，一般用于同步；互斥量一般用于访问公共资源，简单的互斥访问；</p>
<p>  二值信号量可以由其他任务释放，（获取&#x2F;释放），比如一个任务take了一个二值信号量，需要等待其他任务完成，释放这个信号量，才会继续。这样就形成了同步，这个任务依赖于其他任务发布同步信号；</p>
<p>  但是互斥量只能由获取的任务释放，只能用于单个任务访问临界资源；</p>
</li>
<li><p>任务通知是怎么实现的：【任务通知是每一个任务都有的32位的变量】&#x3D;</p>
<p>  <strong>1. 任务通知简介</strong></p>
<p>  任务通知在 FreeRTOS 中是一个可选的功能，要使用任务通知的话就需要将宏 configUSE_TASK_NOTIFICATIONS 定义为 1。 FreeRTOS 的<strong>每个任务都有一个 32 位的通知值</strong>，任务控制块中的成员变量 ulNotifiedValue 就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞的话，向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态。也可以更新接收任 务的任务通知值，任务通知可以通过如下方法更新接收任务的通知值：</p>
<p>  ● 不覆盖接收任务的通知值(如果上次发送给接收任务的通知还没被处理)。</p>
<p>  ● 覆盖接收任务的通知值。</p>
<p>  ● 更新接收任务通知值的一个或多个 bit。</p>
<p>  ● 增加接收任务的通知值。</p>
</li>
<li><p>【0920】零跑 嵌入式OS：</p>
<ul>
<li><p>任务划分周期怎么考虑：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39269366/article/details/120548641">指路CSDN——&gt;</a></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2072.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>任务堆栈分配怎么考虑的？</p>
</li>
<li><p>移植FreeRTOS？<a target="_blank" rel="noopener" href="https://www.notion.so/STM32_HAL-2023-10-15-996797e72af14652b327f262d8b0ad9f?pvs=21">指路——&gt;</a>【也包含了任务划分技巧】<a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-STM32HAL-8-14-22d01922723e441a970d342ac41f20f9?pvs=21">指路0925——&gt;</a></p>
</li>
</ul>
</li>
<li><p>FreeRTOS的版本？内核版本(v9.0.0 v10.6.0 等)，库版本(带时间的都是库函数版本)：</p>
<p>  FreeRTOS主要版本的区别是什么？这是一个很好的问题，我尝试用简单的语言来回答一下。</p>
<p>  <a target="_blank" rel="noopener" href="https://www.freertos.org/">FreeRTOS是一种实时操作系统内核，它适用于嵌入式设备，可以在多种微控制器和小型微处理器上运行。1 FreeRTOS的版本有两种类型：内核版本和库版本。</a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeRTOS">2</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeRTOS">内核版本是指FreeRTOS内核的版本，它负责实现任务管理、内存管理、时间管理等基本功能。2</a> <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/freertos/latest/userguide/what-is-freertos.html">内核版本的更新主要是为了修复错误、增加兼容性、提高性能和稳定性等。3 内核版本的命名方式是Vx.y.z，其中x表示主版本号，y表示次版本号，z表示修订号。3</a> <a target="_blank" rel="noopener" href="https://www.freertos.org/">例如，最新的内核版本是V10.6.0，于2023年7月13日发布。1</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/FreeRTOS">库版本是指FreeRTOS提供的一些附加库的版本，它们负责实现一些高级功能，如网络通信、文件系统、命令行接口、安全协议等。2</a> 库版本的更新主要是为了增加新功能、支持新平台、改进用户体验等。 库版本的命名方式是Vx.y.z-yyyy-mm-dd，其中x表示主版本号，y表示次版本号，z表示修订号，yyyy-mm-dd表示发布日期。 例如，最新的库版本是V202107.00-2021-07-13，于2023年7月13日发布。</li>
</ul>
<p>  FreeRTOS还提供了一种长期支持（LTS）版本，它是一种特殊的库版本，它包含了一个经过验证和测试的内核版本和一组稳定和安全的库。 LTS版本的目的是为了提供一个可靠和持久的平台，它可以在两年内获得安全更新和关键错误修复。 LTS版本的命名方式是Vx.y-LTS-yyyy-mm-dd，其中x表示主版本号，y表示次版本号，yyyy-mm-dd表示发布日期。 例如，最新的LTS版本是V10.4-LTS-2020-12-18，于2020年12月18日发布。</p>
<p>  我希望这能够回答你的问题，如果你还有其他关于FreeRTOS或其版本的问题，欢迎继续提问。😊
  </p>
</li>
<li><p>FreeRTOS内核版本9和版本10有什么区别：核心没有区别，主要就是10多了流缓冲区；</p>
<p>  FreeRTOS 内核版本 v9.0 和 v10.0 的区别主要有以下几点：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/rtos/freertos/zh/latest/zero_to_one/first_sight.html">FreeRTOS v10.0 是在 v9.0 的基础上增加了两个重要的新特性：流缓冲区（Stream Buffers）和消息缓冲区（Message Buffers）。流缓冲区是一种用于单个读者和单个写者之间的通信的机制，适用于从中断服务程序（ISR）到任务或从一个处理器核心到另一个处理器核心的数据流传输。消息缓冲区是在流缓冲区的基础上，增加了发送和接收不同长度的离散消息的功能。</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=FreeRTOS+%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC+v9.0+%E5%92%8C+v10.0+%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F">1</a><a target="_blank" rel="noopener" href="https://doc.embedfire.com/rtos/freertos/zh/latest/zero_to_one/first_sight.html">2</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/rtos/freertos/zh/latest/zero_to_one/first_sight.html">FreeRTOS v10.0 改变了一个头文件的名称，将 StackMacros.h 重命名为 stack_macros.h，以保持一致性。同时，为了兼容性，提供了两个版本的头文件，一个是旧名称，一个是新名称。2</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.embedfire.com/rtos/freertos/zh/latest/zero_to_one/first_sight.html">FreeRTOS v10.0 增加了一个新的源文件 stream_buffers.c，用于实现流缓冲区和消息缓冲区的功能。如果不需要使用这些新特性，可以不添加这个源文件。2</a></li>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/freertos/files/FreeRTOS/">FreeRTOS v10.0 修复了一些错误，增加了一些兼容性和性能的改进。3</a></li>
</ul>
<p>  总的来说，FreeRTOS v10.0 是一个向后兼容的版本，除了增加了一些高级功能和改进外，内核的基本功能和接口没有变化。如果想要使用新特性，需要添加新的源文件和头文件，并修改相应的配置参数。如果想要继续使用旧版本的功能，可以直接替换内核源文件和头文件，不需要做其他修改。</p>
<p>  我希望这能够回答你的问题，如果你还有其他关于FreeRTOS或其内核版本的问题，欢迎继续提问。😊
  </p>
</li>
<li><p>FreeRTOS的RVDS文件夹中有 ARM_CM0 ARM_CM3 ARM_CM4_MPU ARM_CM7 这些代表了什么？ARM Cortex-M0 、ARM Cortex-M3 等等；文件夹里就两个文件 port.c、 portmacro.h；主要用于适配不同的芯片</p>
<p>  RVDS是RealView Development Suite的缩写，它是一种基于ARM架构的集成开发环境（IDE），包括编译器、调试器、仿真器等工具。 FreeRTOS支持RVDS以及其他常见的编译器，如Keil、IAR、GCC等。</p>
</li>
<li><p>进程和线程的区别：</p>
<p>  进程和线程的区别是什么？这是一个关于操作系统的基本概念的问题，我尝试用简单的语言来回答一下。</p>
<p>  进程和线程都是操作系统中实现多任务的方式，但是它们有以下几个主要的区别：</p>
<ul>
<li>进程是程序在某个数据集合上的一次运行活动，也是<strong>操作系统进行资源分配和保护的基本单位。</strong>¹ 线程是进程内的一个执行单元，<strong>也是CPU调度和分派的基本单位</strong>，它是比进程更小的能独立运行的基本单位。²</li>
<li>进程有自己独立的地址空间和资源，每个进程之间是相互隔离的。¹ 线程共享所属进程的地址空间和资源，每个线程之间可以相互通信和协作。²</li>
<li>进程的创建和销毁比较耗费时间和资源，需要进行上下文切换。¹ 线程的创建和销毁比较轻量级，开销较小，切换速度快。²</li>
<li>进程可以拥有多个线程，一个进程至少有一个线程。² 线程不能拥有其他线程，但可以拥有协程，协程是一种比线程更加轻量级的存在。³</li>
</ul>
<p>  我希望这能够回答你的问题，如果你还有其他关于操作系统或其他相关话题的问题，欢迎继续提问。😊</p>
<p>  源: 与必应的对话， 2023&#x2F;9&#x2F;21<br>  (1) 面试必考 | 进程和线程的区别 - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/114453309">https://zhuanlan.zhihu.com/p/114453309</a>.<br>  (2) 五分钟扫盲：进程与线程基础必知 - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/403313422">https://zhuanlan.zhihu.com/p/403313422</a>.<br>  (3) 一文带你彻底搞懂Python进程与线程 - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/443244979">https://zhuanlan.zhihu.com/p/443244979</a>.<br>  (4) 操作系统：进程与线程之间的区别及联系 - 知乎. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505594640">https://zhuanlan.zhihu.com/p/505594640</a>.<br>  (5) 进程和线程的区别是什么？ - 牛客网. <a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/234895a70e0b40e19db7f3fbaabc5fa3">https://www.nowcoder.com/questionTerminal/234895a70e0b40e19db7f3fbaabc5fa3</a>.
  </p>
</li>
<li><p>【0925】FreeRTOS常见问题：移植到不同的Cortex-M核？占用ROM大小？CPU时钟频率？中断优先级【调用了FreeRTOSAPI的中断 其优先级不能高于configMAX_SYSCALL_INTERRUPT_PRIORITY】？</p>
<h1 id="FreeRtos-STM32上使用freertos常见问题"><a href="#FreeRtos-STM32上使用freertos常见问题" class="headerlink" title="FreeRtos:STM32上使用freertos常见问题"></a><strong>FreeRtos:STM32上使用freertos常见问题</strong></h1><ul>
<li>怎样将 FreeRTOS 移植到不同的 Cortex-M 内核？</li>
<li>FreeRTOS 使用多少 ROM&#x2F;RAM？</li>
<li>怎样设置 CPU 时钟？</li>
<li>怎样设置中断优先级？</li>
<li>怎样使用非 SysTick 时钟生成时间片中断？</li>
<li>怎样启用无时间片空闲模式？</li>
</ul>
<p>  STM32上使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=freertos&spm=1001.2101.3001.7020">freertos</a>常见问题，来自STM32的官方文档，这里把部分摘录在这里。</p>
<h2 id="怎样将-FreeRTOS-移植到不同的-Cortex-M-内核？"><a href="#怎样将-FreeRTOS-移植到不同的-Cortex-M-内核？" class="headerlink" title="怎样将 FreeRTOS 移植到不同的 Cortex-M 内核？"></a><strong>怎样将 FreeRTOS 移植到不同的 Cortex-M 内核？</strong></h2><p>  若需将 FreeRTOS 移植到正确的 Cortex-M 产品，您必须从正确的目录导入 “port.c”。例如，若微控制器是带有 IAR 工具的 Cortex-M0 内核，则您必须从</p>
<p>  “FreeRTOS\Source\portable\IAR\ARM_CM0” 获取 port.c。</p>
<h2 id="FreeRTOS-使用多少-ROM-RAM？"><a href="#FreeRTOS-使用多少-ROM-RAM？" class="headerlink" title="FreeRTOS 使用多少 ROM&#x2F;RAM？"></a><strong>FreeRTOS 使用多少 ROM&#x2F;RAM？</strong></h2><p>  这取决于您的编译器、架构，以及 RTOS 内核配置。一般来说， RTOS 内核本身需要大约 5到 10 K 字节 ROM 空间。如果创建的线程或队列数增加， RAM 使用量就会上升。</p>
<h2 id="怎样设置-CPU-时钟？"><a href="#怎样设置-CPU-时钟？" class="headerlink" title="怎样设置 CPU 时钟？"></a><strong>怎样设置 CPU 时钟？</strong></h2><p>  CPU 时钟由 FreeRTOSConfig.h 中的 configCPU_CLOCK_HZ 定义，在 STM32CubeF4固件内它由 SystemCoreClock 提供，表示 HCLK 时钟 （AHB 总线），当通过调用SystemClock_Config() 函数配置 RCC 时钟时会设置此值。</p>
<h2 id="怎样设置中断优先级？"><a href="#怎样设置中断优先级？" class="headerlink" title="怎样设置中断优先级？"></a><strong>怎样设置中断优先级？</strong></h2><p>  任何使用 RTOS API 函数的中断服务程序，其优先级必须手动设置为大于等于</p>
<p>  FreeRTOSConfig.h 文件中 configMAX_SYSCALL_INTERRUPT_PRIORITY 的设置值。这确保了中断的逻辑优先级小于等于 configMAX_SYSCALL_INTERRUPT_PRIORITY设置。</p>
<h2 id="怎样使用非-SysTick-时钟生成时间片中断？"><a href="#怎样使用非-SysTick-时钟生成时间片中断？" class="headerlink" title="怎样使用非 SysTick 时钟生成时间片中断？"></a><strong>怎样使用非 SysTick 时钟生成时间片中断？</strong></h2><p>  用户可选择性地自己提供时间片中断源，方法是使用非 SysTick 的定时器生成中断：</p>
<ul>
<li>提供 vPortSetupTimerInterrupt() 的实现，它会以 configTICK_RATE_HZFreeRTOSConfig.h 常量指定的频率生成中断。</li>
<li>将 xPortSysTickHandler() 安装为定时器中断的处理程序，确保 xPortSysTickHandler()在 FreeRTOSConfig.h 中未映射至 SysTick_Handler()，且在 port.c 中未重命名为SysTick_Handler()。</li>
</ul>
<h2 id="怎样启用无时间片空闲模式？"><a href="#怎样启用无时间片空闲模式？" class="headerlink" title="怎样启用无时间片空闲模式？"></a><strong>怎样启用无时间片空闲模式？</strong></h2><p>  FreeRTOS 无时间片模式 （低功耗）通过进入睡眠模式并停止周期性的时间片中断来降低MCU 功耗。在 FreeRTOSConfig.h 中，将 configUSE_TICKLESS_IDLE 定义为 1，即可启用此功能当使用非 SysTick 定时器生成时间片中断时，也可启用无时间片空闲模式。用户必须添加下列动作至上一个问题所述内容：</p>
<ul>
<li>在 FreeRTOSConfig.h 中，将 configUSE_TICKLESS_IDLE 设为 2。</li>
<li>按 FreeRTOS 网站的文档页面说明，定义portSUPPRESS_TICKS_AND_SLEEP()。</li>
</ul>
</li>
<li><p>【0926】FreeRTOS栈溢出检测，0xa5，钩子函数————要点：在任务切换SwitchContext函数中调用了栈溢出检测；如果有检测到栈溢出，就会调用Hook函数进行处理；会传入栈溢出的任务名，只需要导出这个任务名进行后续处理就行；</p>
<h1 id="FreeRTOS中的任务堆栈溢出检测机制-strongerHuang的博客-CSDN博客"><a href="#FreeRTOS中的任务堆栈溢出检测机制-strongerHuang的博客-CSDN博客" class="headerlink" title="FreeRTOS中的任务堆栈溢出检测机制_strongerHuang的博客-CSDN博客"></a><strong>FreeRTOS中的任务堆栈溢出检测机制_strongerHuang的博客-CSDN博客</strong></h1><p>  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/ybhuangfugui/article/details/120897699">blog.csdn.net**&#x2F;ybhuangfugui&#x2F;article&#x2F;details&#x2F;120897699</a></p>
<p>  <a target="_blank" rel="noopener" href="https://g.csdnimg.cn/static/logo/favicon32.ico">https://g.csdnimg.cn/static/logo/favicon32.ico</a></p>
<p>  <strong>关注+星标公众号</strong>，不错过精彩内容</p>
<p>  转自 | 麦克泰技术</p>
<p>  在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=FreeRTOS&spm=1001.2101.3001.7020">FreeRTOS</a>中，每个任务都拥有自己的堆栈，该堆栈的大小由创建任务时xTaskCreate函数的函数参数所决定。</p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/1f6eec8d13b419ca7a74e58a99db4b02.png" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/img_convert/1f6eec8d13b419ca7a74e58a99db4b02.png"></p>
<p>  但当任务所使用的堆栈空间超出分配给它的空间时，则会发生堆栈溢出，堆栈溢出可能修改超过合法访问地址范围外的数据，严重时会导致Hardfault令系统崩溃。</p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/ab3c745ffab408d6f09f8c2a9e4bd522.png" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/img_convert/ab3c745ffab408d6f09f8c2a9e4bd522.png"></p>
<p>  如何设定合理的任务堆栈大小以避免发生堆栈溢出问题呢？</p>
<p>  首先我们需要根据任务函数运行过程中的理论堆栈使用最大值，在任务创建时设定一个合理的任务堆栈大小，并实际运行程序进行测试，来确保系统运行过程中不会发生堆栈溢出。</p>
<p>  <strong>FreeRTOS中的任务堆栈溢出检测机制：</strong></p>
<p>  在FreeRTOS中，也提供了一些API函数用来检测任务堆栈的使用情况，例如：</p>
<p>  uxTaskGetStackHighWaterMark (TaskHandle_t xTask)——返回自任务运行以来剩余可用堆栈空间的最小值</p>
<p>  要使用上述函数，需要在FreeRTOSConfig.h头文件中使能宏“#define INCLUDE_uxTaskGetStackHighWaterMark      1”。该函数会返回任务运行过程中剩余可用堆栈空间的最小值，即任务运行过程中堆栈最大使用量时还剩余多少空间，如果函数返回0则说明可能发生了任务堆栈溢出。在应用中调用该函数可以帮助了解任务堆栈的一个实际使用情况。</p>
<p>  FreeRTOS中还提供了两种堆栈溢出检测方式，需要在FreeRTOSconfig.h头文件中通过宏#define configCHECK_FOR_STACK_OVERFLOW  来进行选择使能：</p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/ea769da6abd4ca277e4648b34f61f500.png" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/img_convert/ea769da6abd4ca277e4648b34f61f500.png"></p>
<p>  两种检测方式在检测原理上存在一些差别，检测方式1是检测运行过程中的任务栈指针，检测方式2则是检测初始化后的数据在运行过程中是否被修改。</p>
<p>  如果任务堆栈溢出检测函数检测到发生了堆栈溢出，则会调用对应的钩子函数（钩子函数需用户手动创建），用户可以在钩子函数中执行想要的操作例如打印发生错误的任务名等。</p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/f706071b5bd1753aeb1c91fd50bcf11b.png" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/img_convert/f706071b5bd1753aeb1c91fd50bcf11b.png"></p>
<p>  <strong>内核在什么时候执行任务堆栈溢出检测：</strong></p>
<p>  在FreeRTOS源码 tasks.c 文件中可以查到taskCHECK_FOR_STACK_OVERFLOW在 void vTaskSwitchContext( void )函数中被调用，也就是在任务上下文切换的时候做检测。从这点可以看出软件检测栈溢出的方式具有一定的滞后性，需要在任务发生上下文切换时才会进行，任务堆栈溢出时并不能马上检测到问题。</p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/a5b2c1925a9b1edd89270eb744f6d641.png" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/img_convert/a5b2c1925a9b1edd89270eb744f6d641.png"></p>
<p>  <strong>任务堆栈溢出检测存在的局限性：</strong></p>
<p>  如上文所述，只有在发生任务上下文切换时才会执行任务堆栈溢出检测，发生如下错误情形时则无法检测到了：</p>
<ul>
<li>任务执行的过程中出现过栈溢出，但任务切换前栈指针又恢复到了正常水平。</li>
<li>任务栈末尾的 16 个字节没有用到，即不会被修改，但是任务栈已经溢出了</li>
<li>任务栈溢出后，把系统中的重要数据修改了导致系统直接进入Hardfault</li>
</ul>
<p>  FreeRTOS提供的堆栈溢出检测会引入任务上下文切换的开销，因此仅推荐在应用开发或者测试阶段使用。虽然存在一定的局限性，但大多常见情况下这些检测机制依然是非常实用的功能，可以帮助用户减少代码中的错误并提高应用程序代码的质量。</p>
<p>  <strong>声明：</strong>本文素材来源网络，版权归原作者所有。如涉及作品版权问题，请与我联系删除。</p>
<ul>
<li>———– <strong>END</strong> ————</li>
</ul>
</li>
</ul>
<h3 id="操作系统——进程与线程"><a href="#操作系统——进程与线程" class="headerlink" title="操作系统——进程与线程"></a>操作系统——进程与线程</h3><ul>
<li><p>【1104】RTOS中的死锁概念、造成死锁的原因、死锁的解决办法：</p>
<h2 id="造成死锁的原因：①-两个任务同时交叉获取对方占有的资源而不释放；②-任务还没释放锁就被删除；-“Task1-正在等待-Task2-持有的资源，而-Task2-正在等待-Task1-持有的资源。因此，会出现死锁情况。”-解决办法：①顺序获取锁；-②先释放锁后删除任务；"><a href="#造成死锁的原因：①-两个任务同时交叉获取对方占有的资源而不释放；②-任务还没释放锁就被删除；-“Task1-正在等待-Task2-持有的资源，而-Task2-正在等待-Task1-持有的资源。因此，会出现死锁情况。”-解决办法：①顺序获取锁；-②先释放锁后删除任务；" class="headerlink" title="  造成死锁的原因：① 两个任务同时交叉获取对方占有的资源而不释放；② 任务还没释放锁就被删除；  “Task1 正在等待 Task2 持有的资源，而 Task2 正在等待 Task1 持有的资源。因此，会出现死锁情况。”  解决办法：①顺序获取锁； ②先释放锁后删除任务；
  "></a>  造成死锁的原因：① 两个任务同时交叉获取对方占有的资源而不释放；② 任务还没释放锁就被删除；<br><br>  “<strong>Task1 正在等待 Task2 持有的资源，而 Task2 正在等待 Task1 持有的资源。因此，会出现死锁情况。</strong>”<br><br>  解决办法：①顺序获取锁； ②先释放锁后删除任务；
  </h2><p>  任务自身死锁：一个任务执行过程中多次获取一个锁造成的死锁；使用递归互斥量解决</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2073.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1104】<em><strong>RTOS锁的一般使用场景</strong></em></p>
<p>  RTOS有时候会因为用户的一句代码造成实时性或是性能降低，锁的正确使用更是能体现这一点。</p>
<p>  一、RTOS一般锁使用情景：</p>
<p>  <strong>Semaphore</strong>：适用于较长代码的保护，或是任务之间、中断与任务之间的同步。如果该函数会引起任务阻塞，则不可以在中断中去获取信号量。</p>
<p>  <strong>Mutex</strong>：适用于三个任务以上抢占的资源保护。因为mutex有优先级反转解决策略。 而<strong>semaphore</strong>一般都没有，所以它只适用于两个任务抢占的资源保护。</p>
<p>  <strong>event flag</strong>：条件组合， 适用任务同步。</p>
<p>  <strong>关中断</strong>：适用于简短的代码，比如x++。因为关闭中断会影响系统关中断时间，会造成系统实时性降低。</p>
<p>  <strong>关调度</strong>：任务调度实时性降低，但是不影响关中断时间，相比关中断，关调度还是比较明智的做法，付出的代价较低。</p>
</li>
<li><p>【1104】进程间的通信方式：</p>
<ul>
<li><strong>管道（Pipe）：</strong>适用于有亲缘关系的进程，是一种单向通信方式。</li>
<li><strong>命名管道（Named Pipe）</strong>：适用于没有亲缘关系的进程，通过特殊文件实现通信。</li>
<li><strong>共享内存（Shared Memory）</strong>：多个进程可以访问同一块物理内存来实现数据共享。</li>
<li><strong>信号量（Semaphore）</strong>：用于进程之间的同步和互斥操作。</li>
<li><strong>消息队列（Message Queue）</strong>：通过消息队列来发送和接收消息，实现异步通信。</li>
<li><strong>套接字（Socket）</strong>：通用的进程间通信机制，可在不同主机间进行通信。</li>
<li>文件：通过操作文件来实现进程间的通信和数据交换。</li>
</ul>
</li>
</ul>
<h2 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h2><ul>
<li><p>哈佛结构和冯诺依曼结构区别？——在于程序和数据是否存储到一起。</p>
<p>  二者的区别就是程序空间和数据空间是否是一体的。冯·诺依曼结构数据空间和地址空间不分开，哈佛结构数据空间和地址空间是分开的。</p>
<p>  哈佛结构用的还是同一总线；</p>
<p>  改进哈弗结构使用了 数据总线，地址总线 分开，基本解决了取数取指令冲突的问题。</p>
</li>
<li><p>CPU的构成——运算器、控制器、寄存器、缓存Cache、总线；</p>
<p>  CPU是中央处理器的缩写，它是计算机的运算核心和控制核心，负责执行计算机指令和处理数据。CPU的组成大概有以下几个部分：</p>
<ul>
<li>控制单元（Control Unit）：它是CPU的指挥中心，负责从内存中取出指令，译码并发出控制信号，指挥其他部件协同工作。</li>
<li>运算单元（Arithmetic Logic Unit，ALU）：它是CPU的执行部件，负责进行算术运算和逻辑运算，如加减乘除、与或非等。</li>
<li>寄存器（Register）：它是CPU内部的高速存储器，用于暂存指令、数据和中间结果。寄存器的数量和功能根据不同的CPU而异，一般分为通用寄存器和专用寄存器。</li>
<li>缓存（Cache）：它是CPU外部的高速存储器，用于缓存常用的指令和数据，减少CPU访问内存的次数和延迟。缓存的容量和层级根据不同的CPU而异，一般分为一级缓存、二级缓存和三级缓存。</li>
<li>总线（Bus）：它是CPU与其他部件（如内存、输入输出设备等）之间的通信通道，用于传送指令、数据和地址等信息。总线的类型和速度根据不同的CPU而异，一般分为数据总线、地址总线和控制总线。</li>
</ul>
</li>
<li><p>8086架构和ARM CM3内核架构区别</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2074.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>Cortex-M3 有 256个中断；16个内核中断240个外部中断</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2075.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1009】BASEPRI寄存器只有高四位有效，因为Cortex-M3只支持16级优先级</p>
</li>
<li><p>16个内核中断中有11个内核异常</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2076.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>异常和中断的区别：</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">异常和中断的区别</a></p>
</li>
<li><p>ARM系统中，在函数调用的时候，参数是通过哪种方式传递的？</p>
<p>  【看FreeRTOS的入栈？】</p>
</li>
<li><p>ARM Cortex-M3 有多少寄 存器？——-16个【特殊寄存器也需要考虑】</p>
<h1 id="CortexM3与M4寄存器学习笔记-怎么读取cortexm4中断寄存器-shizes1989的博客-CSDN博客"><a href="#CortexM3与M4寄存器学习笔记-怎么读取cortexm4中断寄存器-shizes1989的博客-CSDN博客" class="headerlink" title="CortexM3与M4寄存器学习笔记_怎么读取cortexm4中断寄存器_shizes1989的博客-CSDN博客"></a><strong>CortexM3与M4寄存器学习笔记_怎么读取cortexm4中断寄存器_shizes1989的博客-CSDN博客</strong></h1><p>  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/shizes1989/article/details/96132855">blog.csdn.net**&#x2F;shizes1989&#x2F;article&#x2F;details&#x2F;96132855</a></p>
<p>  <a target="_blank" rel="noopener" href="https://g.csdnimg.cn/static/logo/favicon32.ico">https://g.csdnimg.cn/static/logo/favicon32.ico</a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/shizes1989/category_9132924.html">ARM内核学习 专栏收录该内容</a></p>
<p>  <img src="https://img-blog.csdnimg.cn/20201014180756925.png?x-oss-process=image/resize,m_fixed,h_64,w_64" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20201014180756925.png?x-oss-process=image/resize,m_fixed,h_64,w_64"></p>
<p>  3 篇文章 1 订阅</p>
<p>  订阅专栏</p>
<h1 id="寄存器学习"><a href="#寄存器学习" class="headerlink" title="寄存器学习"></a><strong>寄存器学习</strong></h1><p>  CortexM3和M4处理器的寄存器组中有16个寄存器，其中13个为32位通用目的寄存器，其它3个有特殊用途，如下图所示。</p>
<p>  <img src="https://img-blog.csdnimg.cn/20190716142538298.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70," srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190716142538298.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70,"></p>
<h2 id="1、R0-R12"><a href="#1、R0-R12" class="headerlink" title="1、R0~R12"></a><strong>1、R0~R12</strong></h2><p>  寄存器R0-R12为通用目的寄存器，前8个（R0-R7）也被称作低寄存器。由于指令中可用的空间有限，许多16位指令只能访问低寄存器。高寄存器（R8-R12）则可以用于32位指令和几个16位指令，如MOV。R0-R12的初始值是未定义的。</p>
<h2 id="2、R13，栈指针（SP）"><a href="#2、R13，栈指针（SP）" class="headerlink" title="2、R13，栈指针（SP）"></a><strong>2、R13，栈指针（SP）</strong></h2><p>  物理上存在两个栈指针：主栈指针（MSP，SP_main）为默认的栈指针。另一个为进程栈指针（PSP，SP_process）,其只能用在线程模式。</p>
<h2 id="3、R14，链接寄存器（LR）"><a href="#3、R14，链接寄存器（LR）" class="headerlink" title="3、R14，链接寄存器（LR）"></a><strong>3、R14，链接寄存器（LR）</strong></h2><p>  LR用于函数或子程序调用时返回地址的保存。在函数或子程序结束时，程序控制可以通过将LR的数值加载程序计数器（PC）中返回调用程序处并继续执行。当执行了函数或子程序调用后，LR的数值会自动更新。若某函数需要调用另外一个函数或子程序，则它需要首先将LR的数值保存在栈中，否则，当执行了函数调用后，LR的当前值会丢失。</p>
<h2 id="4、R15，程序计数器（PC）"><a href="#4、R15，程序计数器（PC）" class="headerlink" title="4、R15，程序计数器（PC）"></a><strong>4、R15，程序计数器（PC）</strong></h2><p>  PC是可读可写的，读操作返回当前指令地址加4（由于设计的流水线特性），写PC会引起跳转操作。</p>
<p>  由于指令必须要对齐到半字或字地址，PC的最低位为0。不过，在使用一些跳转&#x2F;读存储器指令更新PC时，需要将新PC值的LSB置1以表示Thumb状态，否则就会由于试图使用不支持的ARM指令而触发错误异常。对于高级编程语音（包括C和C++），编译器会自动将跳转目标的LSB置位。</p>
<h2 id="5、特殊寄存器"><a href="#5、特殊寄存器" class="headerlink" title="5、特殊寄存器"></a><strong>5、特殊寄存器</strong></h2><p>  处理器存在多个特殊寄存器，如下图所示。这些寄存器表示处理器状态、定义了操作状态和中断&#x2F;异常屏蔽。</p>
<p>  <img src="https://img-blog.csdnimg.cn/20190716150058934.jpg?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=#pic_center" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190716150058934.jpg?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=#pic_center"></p>
<p>  特殊寄存器未经过存储器映射，可以使用MSR和MRS等特殊寄存器访问指令来进行访问。</p>
<blockquote>
<p>MRS &lt; reg &gt;,&lt; special_reg &gt; ； 将特殊寄存器读入寄存器</p>
<p>MSR &lt; special_reg &gt;,&lt; reg &gt; ； 写入特殊寄存器</p>
</blockquote>
<h3 id="5-1、程序状态寄存器"><a href="#5-1、程序状态寄存器" class="headerlink" title="5.1、程序状态寄存器"></a><strong>5.1、程序状态寄存器</strong></h3><p>  程序状态寄存器包括三个状态寄存器:</p>
<ul>
<li>应用PSR（APSR）</li>
<li>执行PSR（EPSR）</li>
<li>中断PSR（IPSR）</li>
</ul>
<p>  这三个寄存器可以通过一个组合寄存器访问，该寄存器在有些文献中也被称作xPSR。对于ARM汇编器，在访问xPSR时使用的是PSR。例如：</p>
<blockquote>
<p>MRS r0，PSR</p>
<p>MSR PSR，r0</p>
</blockquote>
<p>  还可以单独访问每个PSR。每个PSR的定义如下图所示。</p>
<p>  <img src="https://img-blog.csdnimg.cn/20190716152103809.jpg" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190716152103809.jpg"></p>
<p>  <img src="https://img-blog.csdnimg.cn/2019071615215887.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/2019071615215887.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70"></p>
<h3 id="5-2、PRIMASK、FAULTMASK和BASEPRI寄存器"><a href="#5-2、PRIMASK、FAULTMASK和BASEPRI寄存器" class="headerlink" title="5.2、PRIMASK、FAULTMASK和BASEPRI寄存器"></a><strong>5.2、PRIMASK、FAULTMASK和BASEPRI寄存器</strong></h3><p>  <img src="https://img-blog.csdnimg.cn/20190716163248670.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190716163248670.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70"></p>
<h3 id="5-2-1、PRIMASK"><a href="#5-2-1、PRIMASK" class="headerlink" title="5.2.1、PRIMASK"></a><strong>5.2.1、PRIMASK</strong></h3><p>  PRIMASK寄存器为1位宽的中断屏蔽寄存器。在置位时，它会阻止不可屏蔽中断（NMI）和HardFault异常之外的所有异常。</p>
<h3 id="5-2-2、FAULTMASK"><a href="#5-2-2、FAULTMASK" class="headerlink" title="5.2.2、FAULTMASK"></a><strong>5.2.2、FAULTMASK</strong></h3><p>  FAULTMASK和PRIMASK非常类似，不过它还能屏蔽HardFault异常。</p>
<h3 id="5-2-3、BASEPRI"><a href="#5-2-3、BASEPRI" class="headerlink" title="5.2.3、BASEPRI"></a><strong>5.2.3、BASEPRI</strong></h3><p>  为使中断屏蔽更加灵活，该寄存器会根据优先级屏蔽异常或中断。BASEPRI为0时不会起作用，当被设置为非0数值时，它就会屏蔽具有相同或更低优先级的异常（包括中断），而高优先级的还可以被处理器接受。</p>
<p>  CMSIS-Core提供了多个C函数用于访问上述3个寄存器。</p>
<blockquote>
<p>x &#x3D; _get_BASEPRI(); &#x2F;&#x2F; 读BASEPRI寄存器</p>
<p>x &#x3D; _get_PRIMASK(); &#x2F;&#x2F; 读PRIMASK寄存器</p>
<p>x &#x3D; _get_FAULTMASK(); &#x2F;&#x2F; 读FAULTMASK寄存器</p>
<p>_set_BASEPRI(x); &#x2F;&#x2F; 设置BASEPRI的值</p>
<p>_set_PRIMASK(x); &#x2F;&#x2F; 设置PRIMASK的值</p>
<p>_set_FAULTMASK(x); &#x2F;&#x2F; 设置FAULTMASK的值</p>
<p>_disable_irq(); &#x2F;&#x2F; 设置PRIMASK，禁止IRQ</p>
<p>_enable_irq(); &#x2F;&#x2F; 清除PRIMASK，使能IRQ</p>
</blockquote>
<p>  还可以用汇编代码访问这些寄存器。</p>
<blockquote>
<p>MRS r0，BASEPRI</p>
<p>MRS r0，PRIMASK</p>
<p>MRS r0，FAULTMASK</p>
<p>MSR BASEPRI，r0</p>
<p>MSR PRIMASK，r0</p>
<p>MSR FAULTMASK，r0</p>
</blockquote>
<p>  另外，利用修改处理器状态（CPS）指令，可以很方便的设置或清除PRIMASK和FAULTMASK的数值。</p>
<blockquote>
<p>CPSIE i ; 使能中断（清除PRIMASK）</p>
<p>CPSID i ; 禁止中断（设置PRIMASK）</p>
<p>CPSIE f ; 使能中断（清除FAULTMASK）</p>
<p>CPSID f ; 禁止中断（设置FAULTMASK）</p>
</blockquote>
<h3 id="5-3、CONTROL寄存器"><a href="#5-3、CONTROL寄存器" class="headerlink" title="5.3、CONTROL寄存器"></a><strong>5.3、CONTROL寄存器</strong></h3><p>  <img src="https://img-blog.csdnimg.cn/20190716170149616.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190716170149616.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70"></p>
<p>  <img src="https://img-blog.csdnimg.cn/20190716170311270.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20190716170311270.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXplczE5ODk=,size_16,color_FFFFFF,t_70"></p>
<p>  未完待续…
  </p>
</li>
<li><p>ARM Cortex-M3 寄存器总结：</p>
<p>  核心寄存器</p>
<p>  R0~R12 都是通用寄存器；</p>
<p>  R13 SP 堆栈寄存器；</p>
<p>  R14 LR 返回地址寄存器；</p>
<p>  R15 PC 程序指针；</p>
<p>  特殊寄存器</p>
<p>  xPSR 程序状态寄存器</p>
<p>  APSR</p>
<p>  IPSR</p>
<p>  EPSR</p>
<p>  BASEPRI 类型的中断屏蔽寄存器；【特权模式下才能访问这类寄存器】</p>
<p>  ——常用的就是BASEPRI，其有8位，作用就是屏蔽数值大于该寄存器中值的中断或异常；</p>
<p>  CONTROL 控制寄存器；</p>
<p>  只考虑其低2位；</p>
<p>  CONTROL[ 0 ] 选择特权模式或用户线程模式</p>
<p>  CONTROL[ 1 ] 选择堆栈指针功能 是MSP还是PSP</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2077.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  然后 ARM 内核 → Cortex-M3是处理器 → STM32是MCU，所以ICSR寄存器是属于Cortex-M3的寄存器，不属于ARM内核架构的寄存器；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2078.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>Cortex-M3 支持的两种模式——特权模式和线程模式( Handler 、Thread )</p>
<p>  用户级和特权级的实现是为了<strong>给存储器提供一种保护机制</strong>，让用户代码不能访问特定的存储区域。</p>
<p>  只有特权级级代码才能有权限访问特定的存储区域。防止用户代码或者应用代码意外或恶意访问操作系统的数据存储区域。</p>
<p>  用户在线程模式，用户代码，只能通过SVC中断，发出SVC异常，才能进入特权级；</p>
<p>  特权模式能通过修改CONTROL的位来进入线程模式，但是线程模式只能通过SVC进入特权。</p>
<p>  中断、异常 都是特权模式，</p>
<p>  线程模式用 PSP；特权模式用 MSP；</p>
</li>
<li><p>SVC 和 PendSV</p>
<p>  SVC：操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。</p>
<p>  PendSV：是为系统设备而设的“可悬挂请求”（pendable request）。上下文切换 不能在中断中进行，会导致中断延期。为了解决这个问题，使用 PendSV。PendSV可以挂起，也就是等到别的 ISR结束后缓期执行。</p>
</li>
<li><p>ARM指令集分为几类？</p>
</li>
<li><p>操作系统采用缓冲技术,通过减少对CPU的中断次数,提高资源的利用率 怎么理解？</p>
<p>  比如UART的缓冲区，接收到数据不会触发中断，数据量到达一定程度才会触发，减少了CPU请求，减少CPU负担；</p>
<p>  这句话的意思是，操作系统为了解决CPU和I&#x2F;O设备之间速度不匹配的问题，使用了缓冲技术。缓冲技术是在内存中设置一块或多块缓冲区，用于暂存I&#x2F;O设备和CPU之间交换的数据。这样可以减少CPU直接访问I&#x2F;O设备的次数，从而减少中断的发生，提高CPU和I&#x2F;O设备的并行性和效率12。</p>
<p>  举个例子，假设有一个程序需要从磁盘读取数据并进行计算。如果没有缓冲技术，那么程序每次读取一个数据就要向磁盘发出请求，然后等待磁盘返回数据，这个过程会产生一次中断，并且很耗时。如果有缓冲技术，那么程序可以一次性从磁盘读取多个数据到缓冲区中，然后从缓冲区中快速获取数据进行计算，这样就可以减少对磁盘的访问次数和中断次数，提高程序的运行速度。</p>
<p>  <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF/1937843">缓冲技术主要有以下几种方式1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoukun1008/article/details/44999447">2</a>：</p>
<ul>
<li>单缓冲：在内存中设置一个缓冲区，用于存放I&#x2F;O设备和CPU之间交换的数据。这种方式简单，但是不能实现I&#x2F;O设备和CPU的并行操作。</li>
<li>双缓冲：在内存中设置两个缓冲区，一个用于存放I&#x2F;O设备输入的数据，另一个用于存放CPU输出的数据。这种方式可以实现I&#x2F;O设备和CPU的部分并行操作。</li>
<li>缓冲池：在内存中设置多个缓冲区，组成一个缓冲池。缓冲池可以根据需要动态分配给不同的I&#x2F;O设备和CPU，实现更高效的并行操作。</li>
</ul>
</li>
<li><p>同步、互斥：<strong>同步_依赖关系</strong>；互斥_不能同时执行；</p>
<p>  同步： 一种依赖关系，A任务运行完了，B任务才能运行。</p>
<p>  互斥： 访问同一个资源时，同一时刻只能有一个获得，一个使用完后才能轮到下一个</p>
</li>
<li><p>寄存器是最快的 最接近Core的    CPU＞寄存器＞缓存＞内存＞flash，容量相反</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2079.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>STM32启动流程 到FreeRTOS启动流程 Cortex-M3 寄存器</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">指路————&gt;</a></p>
<p>  STM32启动到main之后，配置完外设，就会调用启动调度器的函数；指路——&gt;</p>
<p>  启动调度器的</p>
</li>
<li><p>【1015】启动流程中，从0x0800 0000 取堆栈地址，0x0800 0004取中断向量表地址：</p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/430014447">https://zhuanlan.zhihu.com/p/430014447</a></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2080.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2081.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
<h2 id="单片机-外设"><a href="#单片机-外设" class="headerlink" title="单片机 外设"></a>单片机 外设</h2><ul>
<li><p>stm32 flash、ram占用大小， Code、RO-data、RW-dat、ZI-data 分别代表什么意思</p>
<p>  <strong>Code</strong>：代码占用的空间大小（占用的空间为内部Flash）</p>
<p>  <strong>RO-data</strong>：只读常量大小（如const常量）</p>
<p>  <strong>RW-data</strong>：初始化了的或被初始化为0的可读写变量的大小 。 即：ARM C程序中，所有的未初始化变量都会被自动初始化为0。</p>
<p>  <strong>ZI-data</strong> ：没有初始化的可读写变量的大小 。ZI-data不会被算做代码里因为不会被初始化;</p>
<p>  烧写完的时：<strong>FLASH</strong>大小 ：Code + RO Data + RW Data</p>
<p>  运行的时候： <strong>RAM</strong>大小 ： RW Data + ZI Data，当然还要有堆栈的空间。</p>
<p>  <img src="https://img-blog.csdnimg.cn/20200705155925993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY3MjA5NA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20200705155925993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY3MjA5NA==,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>GPIO</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2082.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<ul>
<li><p>GPIO的八种模式：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2083.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>中断【1009更新】</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">什么是中断？<br>	打断正常执行流程的紧急程序；<br>中断的触发方式有哪些？<br>哪些函数不能在中断中使用？<br>什么叫不可重入函数？<br>中断与异常有何区别？<br>中断的响应执行流程是什么？<br>写一个中断服务需要注意哪些？<br>中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？<br>中断优先级有哪些？<br><br>单片机这种没有操作系统的，中断处理函数不能有输入参数也不能有函数返回<br></code></pre></td></tr></table></figure>
<ul>
<li><p>中断的执行响应流程；中断结束出栈的过程是否可以被打断？——可以；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2084.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p><a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219.md">中断和异常的区别</a>  注意内核16个中断<a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219.md">中有11个异常</a></p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2085.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>中断触发的方式有哪些？</p>
<p>  内部中断；外部中断；软件中断；</p>
<ul>
<li>外部中断：由外部设备或信号引起的中断，例如按键、定时器、串口等。外部中断可以分为可屏蔽中断和不可屏蔽中断，前者可以通过软件控制是否响应，后者必须强制响应。</li>
<li>内部中断：由CPU内部产生的中断，例如除法溢出、非法指令、内存访问错误等。内部中断也叫异常或陷阱，通常是由程序错误或故障引起的。</li>
<li>软件中断：由程序主动发出的中断，例如系统调用(SVC)、断点、调试等。软件中断可以用来实现用户态和内核态的切换，或者实现多任务的切换。</li>
</ul>
</li>
<li><p>哪些函数不能在中断中使用？</p>
<p>  延时函数；会造成阻塞的函数(FreeRTOS中的获取信号量之类)；递归函数(单片机中都不能用)；大量运算函数(sqrt开方函数)；</p>
<ul>
<li>延时函数：例如delay()、sleep()等，这些函数会占用CPU的时间，导致其他中断无法及时响应，或者导致当前程序逻辑出错。</li>
<li>阻塞函数：例如scanf()、getchar()等，这些函数会等待用户输入或者外部数据，导致CPU陷入死循环，或者导致其他中断无法及时响应。</li>
<li>递归函数：例如factorial()、fibonacci()等，这些函数会不断地调用自身，导致堆栈溢出或者内存不足，或者导致其他中断无法及时响应。</li>
<li>大量计算或者复杂操作的函数：例如sqrt()、sin()、cos()等，这些函数会消耗CPU的资源，导致其他中断无法及时响应，或者导致当前程序逻辑出错。</li>
</ul>
</li>
<li><p>什么叫不可重入函数？</p>
<h2 id="可以被多个任务同时调用的函数，而不必担心数据的破坏。"><a href="#可以被多个任务同时调用的函数，而不必担心数据的破坏。" class="headerlink" title="  可以被多个任务同时调用的函数，而不必担心数据的破坏。
  "></a>  可以被多个任务同时调用的函数，而不必担心数据的破坏。
  </h2><p>  可重入函数被几个任务调用的情况</p>
<p>  FreeRTOS中一个任务调用函数，并不是把函数Copy再运行，而是直接从函数所在的内存地址开始执行。如果是可重入函数的话，那么不同的任务可以同时或者交替地调用同一个函数，而不会影响彼此的结果。</p>
<p>  可重入函数是指一个函数可以被中断或者抢占，然后再次被调用，而不会破坏之前的数据或者逻辑的函数。可重入函数的特点有以下几点：</p>
<ul>
<li>不使用全局变量或者静态变量，或者对它们进行保护和同步。</li>
<li>不修改自己的代码或者数据段，或者对它们进行保护和同步。</li>
<li>不调用其他不可重入的函数，或者对它们进行保护和同步。</li>
<li>不依赖于系统的状态或者环境，或者对它们进行保护和同步。</li>
</ul>
<p>  在FreeRTOS中，如果一个任务调用了一个可重入函数，那么该任务可能会被其他更高优先级的任务中断或者抢占，从而导致该函数暂停执行。此时，如果另一个任务也调用了同一个可重入函数，那么它可以正常执行该函数，而不会影响之前被暂停的任务的数据或者逻辑。当之前被暂停的任务恢复执行时，它也可以继续执行该函数，而不会影响之后调用的任务的数据或者逻辑。这样，就实现了多个任务共享同一个可重入函数的功能。</p>
<p>  举例来说，假设有两个任务A和B，它们都要调用一个可重入函数add(x,y)，该函数用于计算两个数的和，并返回结果。假设A要计算add(1,2)，B要计算add(3,4)。当A开始执行add(1,2)时，它会将参数1和2压入栈中，并跳转到add函数的地址开始执行。当A执行到一半时，假设B具有更高的优先级，并且准备就绪，那么B就会中断或者抢占A，并开始执行add(3,4)。此时，B会将参数3和4压入栈中，并跳转到add函数的地址开始执行。由于栈是每个任务独立的空间，所以B不会覆盖A的参数和返回地址。当B执行完add(3,4)后，它会从栈中弹出参数和返回地址，并返回到自己的程序继续执行。此时，A也会恢复执行，并从栈中弹出参数和返回地址，并返回到自己的程序继续执行。这样，A和B都可以正确地得到add函数的结果，而不会相互干扰。
  </p>
</li>
<li><p>写一个中断服务函数需要注意哪些？—— 尽量简短；优先级；一定要记得清除中断标志位；优先级；防止修改中断相关寄存器(LR)；</p>
<ul>
<li>中断服务函数要尽量简短，只做必要的处理，避免过多的计算或者复杂的操作，以减少中断响应时间和堆栈占用。</li>
<li>中断服务函数要尽量不调用其他函数，特别是延时、阻塞、递归等可能会影响中断响应时间或者导致中断嵌套的函数。</li>
<li>中断服务函数要注意保存和恢复寄存器，特别是通用寄存器R0-R3、R12等，因为它们可能会被中断处理函数修改，而影响原来的程序逻辑。</li>
<li>中断服务函数要注意清除中断标志位，以避免重复进入中断或者丢失其他中断。</li>
<li>中断服务函数要注意设置优先级，以避免低优先级的中断被高优先级的中断打断或者屏蔽。</li>
</ul>
</li>
<li><p>中断和轮询哪个效率更高？如何决定是使用轮询还是使用中断方式去驱动？</p>
<p>  效率和适用性要看情况，不是绝对的；</p>
<p>  比如频率比较高的事件，不能用CPU轮询，就像一个任务非常频繁占用CPU去监测某个接口有无数据，CPU控制权90%都在它身上，怎么处理其他任务；所以频率较高的任务用中断即可；</p>
</li>
<li><p>中断的优先级有哪些？——STM32主优先级，抢占优先级；</p>
</li>
<li><p>【0921】进入中断服务函数之后没有清除中断标志位会发生什么？</p>
<ul>
<li><p>首先有三类中断触发：边沿触发，电平触发，软件触发：</p>
<p>  边沿触发不影响，只会在下一个边沿到来时再次调用中断服务函数；</p>
<p>  电平触发会影响；</p>
<p>  重要的是软件触发，软件触发必须要清除中断标志位，否则会一直进入中断，占用CPU</p>
<p>  软件中断比如串口的空闲中断；触发时空闲中断位被置位，需要手动清除掉；</p>
<p>  如果进入中断服务函数之后没有清除中断标志位，会发生什么？这是一个关于STM32的中断机制的问题，我尝试用简单的语言来回答一下。</p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53454834">中断标志位是一种用于表示中断事件发生的标志，它通常由硬件自动设置，需要由软件手动清除。1</a> 如果进入中断服务函数之后没有清除中断标志位，会导致以下几种可能的后果：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouml_msn/article/details/106361936">如果中断是边沿触发的，即当输入信号从低电平变为高电平或从高电平变为低电平时触发中断，那么没有清除中断标志位不会影响下一次中断的触发，只要输入信号再次发生变化。2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouml_msn/article/details/106361936">如果中断是电平触发的，即当输入信号保持在高电平或低电平时触发中断，那么没有清除中断标志位会导致重复进入中断服务函数，直到输入信号恢复到正常电平。这样会占用大量的CPU时间，影响其他任务的执行。2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45847849/article/details/115797441">如果中断是软件触发的，即通过设置某个寄存器或位来触发中断，那么没有清除中断标志位会导致无法再次触发该中断，直到清除了中断标志位。这样会丢失一些重要的中断事件，影响系统的功能。3</a></li>
</ul>
<p>  因此，在编写中断服务函数时，应该遵循一个原则：先清除中断标志位，再执行其他操作。这样可以避免上述问题的发生，保证系统的实时性和可靠性。
  </p>
</li>
<li><p>串口空闲中断：通过设置寄存器的位来触发中断，是软件触发中断；</p>
<p>  空闲中断是属于电平触发的还是软件触发的？这是一个关于STM32的串口通信的问题，我尝试用简单的语言来回答一下。</p>
<p>  <a target="_blank" rel="noopener" href="https://www.sekorm.com/faq/112487.html">根据我在全网搜索的结果1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zn2016/article/details/79041414">，空闲中断是一种特殊的帧中断，它是指在接收到一帧数据后，如果在一个字节的时间内没有再接收到新的数据，就认为该帧数据接收完毕，触发空闲中断。2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/dianqicyuyan/article/details/127805521">3</a></p>
<p>  空闲中断的触发方式取决于串口的工作模式，有两种可能：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a131948.html">如果串口是同步模式，即使用时钟信号来同步发送和接收数据，那么空闲中断是属于电平触发的，即当输入信号保持在高电平时触发中断。4</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hubertboy/p/14810495.html">5</a></li>
<li><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a131948.html">如果串口是异步模式，即使用起始位和停止位来标识发送和接收数据的开始和结束，那么空闲中断是属于软件触发的，即通过设置某个寄存器或位来触发中断。4</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hubertboy/p/14810495.html">5</a></li>
</ul>
<p>  我希望这能够回答你的问题，如果你还有其他关于STM32或串口通信的问题，欢迎继续提问。😊</p>
</li>
</ul>
</li>
<li><p>【0921】如果清除了中断标志位，然后中断没有处理结束，又触发了一次中断，STM32会怎样解决？——【对于同源中断】进入中断服务函数后会屏蔽该中断，如果又有中断触发，不会响应；</p>
<p>  如果清除了中断标志位，然后中断没有处理结束，又触发了一次中断，STM32会怎样解决？这是一个关于STM32的中断机制的问题，我尝试用简单的语言来回答一下。</p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouml_msn/article/details/106361936">STM32的中断机制是基于嵌套向量中断控制器（NVIC）的，它可以根据不同的中断源和优先级来决定是否响应和处理中断。1</a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/424213334">2</a></p>
<p>  如果清除了中断标志位，然后中断没有处理结束，又触发了一次中断，STM32会根据以下几种情况来解决：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1959763145635584700.html">如果两次触发的是同一个中断源，那么STM32会忽略第二次触发的中断请求，继续执行当前的中断服务函数，直到完成后才退出。这是因为STM32在进入一个中断服务函数时，会自动屏蔽该中断源的请求，直到退出时才恢复。3</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53454834">4</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouml_msn/article/details/106361936">如果两次触发的是不同的中断源，且第二次触发的中断优先级高于第一次触发的中断优先级，那么STM32会暂停当前的中断服务函数，先响应和处理第二次触发的高优先级中断，然后再返回继续执行第一次触发的低优先级中断。这是因为STM32支持抢占式优先级机制，可以根据优先级来决定是否打断正在执行的低优先级中断。1</a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/424213334">2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhouml_msn/article/details/106361936">如果两次触发的是不同的中断源，且第二次触发的中断优先级等于或低于第一次触发的中断优先级，那么STM32会等待当前的中断服务函数执行完毕后，再根据响应优先级或者IRQ编号来决定哪个中断先执行。这是因为STM32不允许同优先级或低优先级的中断打断正在执行的高优先级或同优先级的中断。1</a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/424213334">2</a></li>
</ul>
<p>  我希望这能够回答你的问题，如果你还有其他关于STM32或其中断机制的问题，欢迎继续提问。😊
  </p>
</li>
<li><p>【1009】NMI中断是什么？不可屏蔽中断，用于处理致命错误，STM32有一个引脚与NMI中断关联，该引脚收到低电平信号时就会触发NMI中断，调用NMI_Handler；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2086.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>IIC</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">IIC的特点<br>数据有效性<br>三种信号<br>画IIC时序图<br>数据传输流程<br>为什么要上拉？<br>IIC总线怎么实现？<br>IIC工作速率有哪些？<br>IIC上拉电阻怎么选？速率高的话选电阻大的还是小的？<br>怎样用IO口模拟IIC？<br>IIC如何进行读写操作？<br>IIC总线仲裁机制是怎么样的？<br></code></pre></td></tr></table></figure>
<ul>
<li><p>IIC</p>
<ol>
<li><p>I2C</p>
<p> （1）半双工模式。</p>
<p> （2）起始信号 SCL高电平期间 SDA产生下降沿。</p>
<p> （3）ACK应答信号 SCL高电平期间 SDA保持低电平。</p>
<p> （4）NACK应答信号 SCL高电平期间 SDA保持高电平。</p>
<p> （5）数据流 起始信号 +从机地址 + 发送数据标志位 + 应答信号+ 数据 +接收数据。。。应答信号+结束信号。</p>
<p> （6）空闲信号 SCL SDA 都位高电平。</p>
<p> （7）结束信号 SCL位高电平期间 SDA给一个上升沿信号。</p>
</li>
</ol>
</li>
<li><p>IIC时序图：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2087.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  开始结束信号：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2088.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>三种信号：起始信号、结束信号、应答信号——应答信号简述：</p>
<p>  起始和结束信号在时序图中有；</p>
<p>  应答信号：发送方在发送一字节的数据之后，<strong>会释放SDA数据线，让接收方控制</strong>，接收方拉低说明是ACK应答，如果拉高则是NACK非应答，NACK则结束通信；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2089.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>研究应答信号的疑惑 —— GPIO引脚为高阻态，那么设备是怎么监测电平变化的呢？引脚改为输入进行检测？——是的；【通过读取输入端口的电压来判断总线上的逻辑状态】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2090.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>数据传输流程：</p>
<p>  一次传输一个字节的数据；</p>
</li>
<li><p>为什么要上拉？—— 因为IO口是开漏输出，空闲的时候是高阻态(相当于断路)，无法输出高电平只能输出低电平，将总线拉低；</p>
<p>  为什么是高阻态？</p>
<p>  因为有多个器件连接在IIC总线上，如果不屏蔽高电平，会出现短路的情况；</p>
<p>  如果 空闲时低电平输出，则总线直接接地，根本没法传输数据；</p>
<p>  如果 空闲时高电平输出，那么相当于直接接到VCC，这样导致其他设备无法改变总线电平；</p>
</li>
<li><p>IIC的传输速率有哪些：100kb&#x2F;s、300kb&#x2F;s、3.4Mb&#x2F;s</p>
<p>  IIC传输位速率在标准模式下可达100Kbit&#x2F;s，快速模式下可达400Kbit&#x2F;s，高速模式下可达3.4Mbit&#x2F;s；也可以理解为时钟频率在标准模式下可达100kHz，快速模式下可达400kHz，高速模式下可达3.4MHz。</p>
</li>
<li><p>IIC上拉电阻怎么选？速率高的话选电阻大的还是小的？</p>
<p>  典型值：1.5kΩ；2.2kΩ； 4.7KΩ；</p>
<p>  VCC上拉相当于一个弹簧，及时地将总线电平拉高；上拉电阻相当于附加的重量，这个重量越大，恢复为VCC的速度越慢；</p>
<p>  所以速率高要选小一点的上拉电阻；</p>
<p>  实际的原理就是RC充放电电路；</p>
</li>
<li><p>IIC如何进行读写操作？IIC数据帧？通信流程？</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2091.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  IIC主机和从机通信的流程是一种同步的双向的数据交换方式，主要由以下几个步骤组成：</p>
<ul>
<li>主机在检测到总线为空闲状态时，发送一个起始信号S，开始一次通信。</li>
<li>主机发送从机的地址字节，其中最低位表示读或写操作，0表示写，1表示读。</li>
<li>从机收到地址字节后，如果匹配自己的地址，就返回一个应答信号ACK，表示准备好接收或发送数据。</li>
<li>如果主机要写数据到从机，就在时钟线SCL上产生8个时钟脉冲，每个脉冲期间在数据线SDA上发送一个数据位，从高位到低位依次发送。从机在每个字节后返回一个应答信号ACK，表示已经接收到数据。</li>
<li>如果主机要从从机读数据，就在时钟线SCL上产生8个时钟脉冲，每个脉冲期间在数据线SDA上接收一个数据位，从高位到低位依次接收。主机在每个字节后返回一个应答信号ACK，表示准备接收下一个字节。如果主机不想接收更多数据，就在最后一个字节后返回一个非应答信号NACK，表示结束读取。</li>
<li>主机在通信完成后，发送一个停止信号P，结束一次通信。</li>
</ul>
</li>
<li><p>IIC的仲裁机制？—— 线与机制【总线的一个设备接入低电平，那么整条总线就是低电平】；</p>
<p>  首先是线与机制；——低电平优先机制；</p>
<p>  然后就是谁先输出0，谁就占有总线先进行传输；比如一个设备输出1101 另一个是1001 第一位没有区别，然后第二位时后者占据了总线，前者检测到总线为低电平，随即放弃总线；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2092.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>UART</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">usart和uart的区别？<br>uart优缺点？<br>要配置什么参数？<br>时序？<br>传输速率？<br>RX为什么要上拉？<br>怎么传输浮点数？<br>串口如何接收不定长数据？——空闲中断<br>软件怎么实现自动波特率检测？<br></code></pre></td></tr></table></figure>
<ul>
<li><p>UART和USART的区别？—— USART可以是同步也可以是异步；USART有时钟线，比UART逻辑更复杂一点；但是USART传输速度更快：</p>
<p>  UART和USART都是单片机上的串口通信，它们之间的主要区别在于：</p>
<ul>
<li>UART是通用异步收发传输器，只能用于异步通信，也就是说，发送方和接收方之间没有公共时钟，而是通过起始位和停止位来同步数据流。UART的优点是简单易用，缺点是传输速率较慢，且有额外的开销。</li>
<li>USART是通用同步异步收发传输器，既能用于异步通信，也能用于同步通信，也就是说，发送方和接收方之间可以共享一个时钟信号，或者由发送方提供一个时钟信号。USART的优点是传输速率较高，且没有额外的开销，缺点是需要额外的时钟线和控制逻辑。</li>
</ul>
</li>
<li><p>UART优缺点：没有公共时钟线，使用起始位和结束位同步数据流，结构简单；缺点是传输数据慢，而且需要额外开销</p>
<ul>
<li>UART是通用异步收发传输器，只能用于异步通信，也就是说，发送方和接收方之间没有公共时钟，而是通过起始位和停止位来同步数据流。UART的优点是简单易用，缺点是传输速率较慢，且有额外的开销。</li>
</ul>
</li>
<li><p>配置参数：</p>
<p>  波特率：9600；38400；115200；</p>
<p>  数据长度：8Bit; 9Bit(没用过)</p>
<p>  停止位：1 或 2</p>
<p>  奇偶校验；【一般不配置】</p>
</li>
<li><p>传输速度计算：波特率转传输速度公式 Baud&#x2F;s → Bytes&#x2F;s；一般速度在100KB&#x2F;s(?)</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2093.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1021】为什么要这样计算传输的速度？因为 1Baud &#x3D; 1Bit 但是传输一个字节还需要停止位，校验位等，所以比如10次电平变换才传输了一个字节；所以是上面那条计算公式</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2094.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p><strong>RX(TX)为什么要上拉？</strong>—— 防止噪声干扰出现乱码，确定电平；</p>
<p>  UART的RX工作中处于输入状态, 为了避免 RX 无连接(或接触不良)下, 不定电平的噪声导致输入乱码等问题, 加上拉可以确定电平.</p>
</li>
<li><p>串口如何传输浮点数？ —— 拆分成四个Bytes 传输字节即可</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2095.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>UART传输数据原理：<strong>TXRX默认是高电平</strong>；当数据线从高到低跳变一个数据位的时间时，就会触发传输，接收端会根据波特率采样；</p>
<p>  接收数据过程：空闲状态，线路处于高电位；当检测到线路的下降沿（线路电位由高电位变为低电位）时说明线路有数据传输，按照约定的波特率从低位到高位接收数据，数据接收完毕后，接着接收并比较奇偶校验位是否正确，如果正确则通知后续设备准备接收数据或存入缓存。</p>
<p>  由于UART是异步传输，没有传输同步时钟。为了能保证数据传输的正确性，UART采用16倍数据波特率的时钟进行采样。每个数据有16个时钟采样，取中间的采样值，以保证采样不会滑码或误码。一般UART一帧的数据位数为8，这样即使每个数据有一个时钟的误差，接收端也能正确地采样到数据。</p>
<p>  UART的接收数据时序为：当检测到数据的下降沿时，表明线路上有数据进行传输，这时计数器CNT开始计数，当计数器为24&#x3D;16+8时，采样的值为第0位数据；当计数器的值为40时，采样的值为第1位数据，依此类推，进行后面6个数据的采样。如果需要进行奇偶校验，则当计数器的值为152时，采样的值即为奇偶位；当计数器的值为168时，采样的值为“1”表示停止位，一帧数据接收完成。</p>
</li>
<li><p>UART物理层：TTL( 0~3.3V );  RS232( -15 ~ -3V, 3 ~ 15V ); RS485( 差分信号 电压差表示0&#x2F;1  )；</p>
<p>  <strong>TTL</strong></p>
<p>  TTL全名是晶体管-晶体管逻辑集成电路(<code>Transistor-Transistor Logic</code>)</p>
<ul>
<li>输入高电平最小2V，输出高电平最小2.4V，典型值3.4V；</li>
<li>输入低电平最大0.8V，输出低电平最大0.4V，典型值0.2V。</li>
</ul>
<p>  <strong>RS232</strong></p>
<p>  RS232 逻辑1电平(MARK)&#x3D;-3V～-15V，逻辑0电平(SPACE)&#x3D;+3～+15V；</p>
<p>  同样的，对于传输数据<code>0x55</code>，即二进制的<code>01010101</code>，RS232和TTL的区别如下；</p>
<p>  <img src="https://pic2.zhimg.com/80/v2-c76c904423532fcd2f4c9eb24c5069f9_720w.webp" srcset="/img/loading.gif" lazyload alt="https://pic2.zhimg.com/80/v2-c76c904423532fcd2f4c9eb24c5069f9_720w.webp"></p>
<p>  <strong>RS485</strong></p>
<p>  RS485是差分信号进行串行传输；</p>
<ul>
<li>逻辑1以两线间的电压差为<code>+(2~6)V</code>表示；</li>
<li>逻辑”0”以两线间的电压差为<code>(2~6)V</code>表示；</li>
</ul>
<p>  在工业通信中，使用RS485比较多，因为RS485是差分信号，可以抑制共模干扰，因此在恶劣的环境中拥有很好的抗干扰性，比较稳定；
  </p>
</li>
<li><p>【1009】UART时序UART时序UART时序UART时序UART时序UART时序UART时序UART时序</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2096.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>SPI 串行外设接口；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">介绍SPI<br>最大传输速率受什么影响？<br>四种模式及其对应的时序图<br>SPI如何读写？<br>SPI总线怎么实现？<br></code></pre></td></tr></table></figure>
<ul>
<li><p>SPI详解文章：</p>
<h2 id="https-blog-csdn-net-m0-38106923-article-details-124364676-一文搞懂SPI通信协议-spi协议-不脱发的程序猿的博客-CSDN博客-订阅专栏-目录-1、简介-2、通信原理-3、通信特性-3-1、设备选择-3-2、设备时钟-3-2-1、时钟速率-3-2-2、时钟极性-3-2-3、时钟相位-3-3、四种模式-4、多从机模式-5、SPI优缺点"><a href="#https-blog-csdn-net-m0-38106923-article-details-124364676-一文搞懂SPI通信协议-spi协议-不脱发的程序猿的博客-CSDN博客-订阅专栏-目录-1、简介-2、通信原理-3、通信特性-3-1、设备选择-3-2、设备时钟-3-2-1、时钟速率-3-2-2、时钟极性-3-2-3、时钟相位-3-3、四种模式-4、多从机模式-5、SPI优缺点" class="headerlink" title="  https://blog.csdn.net/m0_38106923&#x2F;article&#x2F;details&#x2F;124364676  # 一文搞懂SPI通信协议_spi协议_不脱发的程序猿的博客-CSDN博客  订阅专栏  目录  1、简介  2、通信原理  3、通信特性  3.1、设备选择  3.2、设备时钟  3.2.1、时钟速率  3.2.2、时钟极性  3.2.3、时钟相位  3.3、四种模式  4、多从机模式  5、SPI优缺点
  "></a>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38106923/article/details/124364676">https://blog.csdn.net/m0_38106923&#x2F;article&#x2F;details&#x2F;124364676</a><br><br>  # <strong>一文搞懂SPI通信协议_spi协议_不脱发的程序猿的博客-CSDN博客</strong><br><br>  订阅专栏<br><br>  <strong>目录</strong><br><br>  1、简介<br><br>  2、通信原理<br><br>  3、通信特性<br><br>  3.1、设备选择<br><br>  3.2、设备时钟<br><br>  3.2.1、时钟速率<br><br>  3.2.2、时钟极性<br><br>  3.2.3、时钟相位<br><br>  3.3、四种模式<br><br>  4、多从机模式<br><br>  5、SPI优缺点
  </h2><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a><strong>1、简介</strong></h1><h2 id="SPI是串行外设接口（Serial-Peripheral-Interface）的缩写，是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，是一种高速、全双工、同步通信总线，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M-bps。-SPI有主、从两种模式，通常由一个主模块和一个或多个从模块组成（SPI不支持多主机），主模块选择一个从模块进行同步通信，从而完成数据的交换。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起，当存在多个从设备时，通过各自的片选信号进行管理。-SPI通信原理很简单，需要至少4根线，单向传输时3根线，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）和CS-SS（片选）：-MISO（-Master-Input-Slave-Output）：主设备数据输入，从设备数据输出；-MOSI（Master-Output-Slave-Input）：主设备数据输出，从设备数据输入；-SCLK（Serial-Clock）：时钟信号，由主设备产生；-CS-SS（Chip-Select-Slave-Select）：从设备使能信号，由主设备控制，一主多从时，CS-SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。-一主设备一从设备模式-一主设备多从设备模式-2、通信原理-SPI主设备和从设备都有一个串行移位寄存器，主设备通过向它的SPI串行寄存器写入一个字节来发起一次传输。-SPI数据通信的流程可以分为以下几步：-1、主设备发起信号，将CS-SS拉低，启动通信。-2、主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低），因为SPI有四种模式，后面会讲到），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。-3、主机（Master）将要发送的数据写到发送数据缓存区（Menory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。-4、从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。-例如，下图示例中简单模拟SPI通信流程，主机拉低NSS片选信号，启动通信，并且产生时钟信号，上升沿触发边沿信号，主机在MOSI线路一位一位发送数据0X53，在MISO线路一位一位接收数据0X46，如下图所示：-这里有一点需要着重说明一下：SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节（虚拟数据）；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。-3、通信特性-3-1、设备选择-SPI是单主设备（Single-Master）通信协议，只有一支主设备能发起通信，当SPI主设备想读-写从设备时，它首先拉低从设备对应的SS线（SS是低电平有效）。接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，主设备把信号发到MOSI实现“写”，同时可对MISO采样而实现“读”。如下图所示：-3-2、设备时钟-SPI时钟特点主要包括：时钟速率、时钟极性和时钟相位三方面。-3-2-1、时钟速率-SPI总线上的主设备必须在通信开始时候配置并生成相应的时钟信号。从理论上讲，只要实际可行，时钟速率就可以是你想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的SPI传输速率。-3-2-2、时钟极性-根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据。-CKP可以配置为1或0。这意味着你可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。你必须参考设备的数据手册才能正确设置CKP和CKE。-CKP-0：时钟空闲IDLE为低电平-0；-CKP-1：时钟空闲IDLE为高电平1。-3-2-3、时钟相位-根据硬件制造商的不同，时钟相位通常写为CKE或CPHA。顾名思义，时钟相位-边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；-CKE-0：在时钟信号SCK的第一个跳变沿采样；-CKE-1：在时钟信号SCK的第二个跳变沿采样。-3-3、四种模式-根据SPI的时钟极性和时钟相位特性可以设置4种不同的SPI通信操作模式，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低），详情如下所示：-Mode0：CKP-0，CKE-0：当空闲态时，SCK处于低电平，数据采样是在第1个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在上升沿（准备数据），（发送数据）数据发送是在下降沿。-Mode1：CKP-0，CKE-1：当空闲态时，SCK处于低电平，数据发送是在第2个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。-Mode2：CKP-1，CKE-0：当空闲态时，SCK处于高电平，数据采集是在第1个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。-Mode3：CKP-1，CKE-1：当空闲态时，SCK处于高电平，数据发送是在第2个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。-黑线为采样数据的时刻，蓝线为SCK时钟信号-举个例子，下图是SPI-Mode0读-写时序，可以看出SCK空闲状态为低电平，主机数据在第一个跳变沿被从机采样，数据输出同理。-下图是SPI-Mode3读-写时序，SCK空闲状态为高电平，主机数据在第二个跳变沿被从机采样，数据输出同理。-4、多从机模式-有两种方法可以将多个从设备连接到主设备：多片选和菊花链。-通常，每个从机都需要一条单独的SS线。如果要和特定的从机进行通讯，可以将相应的NSS信号线拉低，并保持其他SS信号线的状态为高电平；如果同时将两个SS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO线上传输数据，最终导致接收数据乱码。-菊花链的最大缺点是信号串行传输，一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了。另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况。-5、SPI优缺点-优点-1-无起始位和停止位，因此数据位可以连续传输而不会被中断；-2-没有像I2C这样复杂的从设备寻址系统；-3-数据传输速率比I2C更高（几乎快两倍）；-4-分离的MISO和MOSI信号线，因此可以同时发送和接收数据；-5-极其灵活的数据传输，不限于8位，它可以是任意大小的字；-6-非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器-晶振（与UART不同）。不需要收发器（与CAN不同）。-缺点-1-使用四根信号线（I2C和UART使用两根信号线）；-2-无法确认是否已成功接收数据（I2C拥有此功能）；-3-没有任何形式的错误检查，如UART中的奇偶校验位；-4-只允许一个主设备；-5-没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；-6-没有定义硬件级别的错误检查协议；-7-与RS-232和CAN总线相比，只能支持非常短的距离；"><a href="#SPI是串行外设接口（Serial-Peripheral-Interface）的缩写，是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，是一种高速、全双工、同步通信总线，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M-bps。-SPI有主、从两种模式，通常由一个主模块和一个或多个从模块组成（SPI不支持多主机），主模块选择一个从模块进行同步通信，从而完成数据的交换。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起，当存在多个从设备时，通过各自的片选信号进行管理。-SPI通信原理很简单，需要至少4根线，单向传输时3根线，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）和CS-SS（片选）：-MISO（-Master-Input-Slave-Output）：主设备数据输入，从设备数据输出；-MOSI（Master-Output-Slave-Input）：主设备数据输出，从设备数据输入；-SCLK（Serial-Clock）：时钟信号，由主设备产生；-CS-SS（Chip-Select-Slave-Select）：从设备使能信号，由主设备控制，一主多从时，CS-SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。-一主设备一从设备模式-一主设备多从设备模式-2、通信原理-SPI主设备和从设备都有一个串行移位寄存器，主设备通过向它的SPI串行寄存器写入一个字节来发起一次传输。-SPI数据通信的流程可以分为以下几步：-1、主设备发起信号，将CS-SS拉低，启动通信。-2、主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低），因为SPI有四种模式，后面会讲到），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。-3、主机（Master）将要发送的数据写到发送数据缓存区（Menory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。-4、从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。-例如，下图示例中简单模拟SPI通信流程，主机拉低NSS片选信号，启动通信，并且产生时钟信号，上升沿触发边沿信号，主机在MOSI线路一位一位发送数据0X53，在MISO线路一位一位接收数据0X46，如下图所示：-这里有一点需要着重说明一下：SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节（虚拟数据）；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。-3、通信特性-3-1、设备选择-SPI是单主设备（Single-Master）通信协议，只有一支主设备能发起通信，当SPI主设备想读-写从设备时，它首先拉低从设备对应的SS线（SS是低电平有效）。接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，主设备把信号发到MOSI实现“写”，同时可对MISO采样而实现“读”。如下图所示：-3-2、设备时钟-SPI时钟特点主要包括：时钟速率、时钟极性和时钟相位三方面。-3-2-1、时钟速率-SPI总线上的主设备必须在通信开始时候配置并生成相应的时钟信号。从理论上讲，只要实际可行，时钟速率就可以是你想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的SPI传输速率。-3-2-2、时钟极性-根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据。-CKP可以配置为1或0。这意味着你可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。你必须参考设备的数据手册才能正确设置CKP和CKE。-CKP-0：时钟空闲IDLE为低电平-0；-CKP-1：时钟空闲IDLE为高电平1。-3-2-3、时钟相位-根据硬件制造商的不同，时钟相位通常写为CKE或CPHA。顾名思义，时钟相位-边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；-CKE-0：在时钟信号SCK的第一个跳变沿采样；-CKE-1：在时钟信号SCK的第二个跳变沿采样。-3-3、四种模式-根据SPI的时钟极性和时钟相位特性可以设置4种不同的SPI通信操作模式，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低），详情如下所示：-Mode0：CKP-0，CKE-0：当空闲态时，SCK处于低电平，数据采样是在第1个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在上升沿（准备数据），（发送数据）数据发送是在下降沿。-Mode1：CKP-0，CKE-1：当空闲态时，SCK处于低电平，数据发送是在第2个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。-Mode2：CKP-1，CKE-0：当空闲态时，SCK处于高电平，数据采集是在第1个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。-Mode3：CKP-1，CKE-1：当空闲态时，SCK处于高电平，数据发送是在第2个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。-黑线为采样数据的时刻，蓝线为SCK时钟信号-举个例子，下图是SPI-Mode0读-写时序，可以看出SCK空闲状态为低电平，主机数据在第一个跳变沿被从机采样，数据输出同理。-下图是SPI-Mode3读-写时序，SCK空闲状态为高电平，主机数据在第二个跳变沿被从机采样，数据输出同理。-4、多从机模式-有两种方法可以将多个从设备连接到主设备：多片选和菊花链。-通常，每个从机都需要一条单独的SS线。如果要和特定的从机进行通讯，可以将相应的NSS信号线拉低，并保持其他SS信号线的状态为高电平；如果同时将两个SS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO线上传输数据，最终导致接收数据乱码。-菊花链的最大缺点是信号串行传输，一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了。另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况。-5、SPI优缺点-优点-1-无起始位和停止位，因此数据位可以连续传输而不会被中断；-2-没有像I2C这样复杂的从设备寻址系统；-3-数据传输速率比I2C更高（几乎快两倍）；-4-分离的MISO和MOSI信号线，因此可以同时发送和接收数据；-5-极其灵活的数据传输，不限于8位，它可以是任意大小的字；-6-非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器-晶振（与UART不同）。不需要收发器（与CAN不同）。-缺点-1-使用四根信号线（I2C和UART使用两根信号线）；-2-无法确认是否已成功接收数据（I2C拥有此功能）；-3-没有任何形式的错误检查，如UART中的奇偶校验位；-4-只允许一个主设备；-5-没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；-6-没有定义硬件级别的错误检查协议；-7-与RS-232和CAN总线相比，只能支持非常短的距离；" class="headerlink" title="  SPI是串行外设接口（Serial Peripheral Interface）的缩写，是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，是一种高速、全双工、同步通信总线，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M&#x2F;bps。  SPI有主、从两种模式，通常由一个主模块和一个或多个从模块组成（SPI不支持多主机），主模块选择一个从模块进行同步通信，从而完成数据的交换。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起，当存在多个从设备时，通过各自的片选信号进行管理。  SPI通信原理很简单，需要至少4根线，单向传输时3根线，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）和CS&#x2F;SS（片选）：  - MISO（ Master Input Slave Output）：主设备数据输入，从设备数据输出；  - MOSI（Master Output Slave Input）：主设备数据输出，从设备数据输入；  - SCLK（Serial Clock）：时钟信号，由主设备产生；  - CS&#x2F;SS（Chip Select&#x2F;Slave Select）：从设备使能信号，由主设备控制，一主多从时，CS&#x2F;SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。    一主设备一从设备模式    一主设备多从设备模式  # 2、通信原理  SPI主设备和从设备都有一个串行移位寄存器，主设备通过向它的SPI串行寄存器写入一个字节来发起一次传输。    SPI数据通信的流程可以分为以下几步：  1、主设备发起信号，将CS&#x2F;SS拉低，启动通信。  2、主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低），因为SPI有四种模式，后面会讲到），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。  3、主机（Master）将要发送的数据写到发送数据缓存区（Menory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。  4、从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。  例如，下图示例中简单模拟SPI通信流程，主机拉低NSS片选信号，启动通信，并且产生时钟信号，上升沿触发边沿信号，主机在MOSI线路一位一位发送数据0X53，在MISO线路一位一位接收数据0X46，如下图所示：    这里有一点需要着重说明一下：SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节（虚拟数据）；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。  # 3、通信特性  ## 3.1、设备选择  SPI是单主设备（Single Master）通信协议，只有一支主设备能发起通信，当SPI主设备想读&#x2F;写从设备时，它首先拉低从设备对应的SS线（SS是低电平有效）。接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，主设备把信号发到MOSI实现“写”，同时可对MISO采样而实现“读”。如下图所示：    ## 3.2、设备时钟  SPI时钟特点主要包括：时钟速率、时钟极性和时钟相位三方面。  ### 3.2.1、时钟速率  SPI总线上的主设备必须在通信开始时候配置并生成相应的时钟信号。从理论上讲，只要实际可行，时钟速率就可以是你想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的SPI传输速率。  ### 3.2.2、时钟极性  根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据。  CKP可以配置为1或0。这意味着你可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。你必须参考设备的数据手册才能正确设置CKP和CKE。  - CKP &#x3D; 0：时钟空闲IDLE为低电平 0；  - CKP &#x3D; 1：时钟空闲IDLE为高电平1。  ### 3.2.3、时钟相位  根据硬件制造商的不同，时钟相位通常写为CKE或CPHA。顾名思义，时钟相位&#x2F;边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；  - CKE &#x3D; 0：在时钟信号SCK的第一个跳变沿采样；  - CKE &#x3D; 1：在时钟信号SCK的第二个跳变沿采样。  ## 3.3、四种模式  根据SPI的时钟极性和时钟相位特性可以设置4种不同的SPI通信操作模式，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低），详情如下所示：  - Mode0：CKP&#x3D;0，CKE &#x3D;0：当空闲态时，SCK处于低电平，数据采样是在第1个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在上升沿（准备数据），（发送数据）数据发送是在下降沿。  - Mode1：CKP&#x3D;0，CKE&#x3D;1：当空闲态时，SCK处于低电平，数据发送是在第2个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。  - Mode2：CKP&#x3D;1，CKE&#x3D;0：当空闲态时，SCK处于高电平，数据采集是在第1个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。  - Mode3：CKP&#x3D;1，CKE&#x3D;1：当空闲态时，SCK处于高电平，数据发送是在第2个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。    黑线为采样数据的时刻，蓝线为SCK时钟信号  举个例子，下图是SPI Mode0读&#x2F;写时序，可以看出SCK空闲状态为低电平，主机数据在第一个跳变沿被从机采样，数据输出同理。    下图是SPI Mode3读&#x2F;写时序，SCK空闲状态为高电平，主机数据在第二个跳变沿被从机采样，数据输出同理。    # 4、多从机模式  有两种方法可以将多个从设备连接到主设备：多片选和菊花链。  通常，每个从机都需要一条单独的SS线。如果要和特定的从机进行通讯，可以将相应的NSS信号线拉低，并保持其他SS信号线的状态为高电平；如果同时将两个SS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO线上传输数据，最终导致接收数据乱码。    菊花链的最大缺点是信号串行传输，一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了。另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况。    # 5、SPI优缺点  - 优点  1. 无起始位和停止位，因此数据位可以连续传输而不会被中断；  2. 没有像I2C这样复杂的从设备寻址系统；  3. 数据传输速率比I2C更高（几乎快两倍）；  4. 分离的MISO和MOSI信号线，因此可以同时发送和接收数据；  5. 极其灵活的数据传输，不限于8位，它可以是任意大小的字；  6. 非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。  - 缺点  1. 使用四根信号线（I2C和UART使用两根信号线）；  2. 无法确认是否已成功接收数据（I2C拥有此功能）；  3. 没有任何形式的错误检查，如UART中的奇偶校验位；  4. 只允许一个主设备；  5. 没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；  6. 没有定义硬件级别的错误检查协议；  7. 与RS-232和CAN总线相比，只能支持非常短的距离；
  "></a>  SPI是串行外设接口（Serial Peripheral Interface）的缩写，是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，是一种高速、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%8F%8C%E5%B7%A5&spm=1001.2101.3001.7020">全双工</a>、同步通信总线，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M&#x2F;bps。<br><br>  SPI有主、从两种模式，通常由一个主模块和一个或多个从模块组成（SPI不支持多主机），主模块选择一个从模块进行同步通信，从而完成数据的交换。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起，当存在多个从设备时，通过各自的片选信号进行管理。<br><br>  SPI<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86&spm=1001.2101.3001.7020">通信原理</a>很简单，需要至少4根线，单向传输时3根线，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）和CS&#x2F;SS（片选）：<br><br>  - MISO（ Master Input Slave Output）：主设备数据输入，从设备数据输出；<br>  - MOSI（Master Output Slave Input）：主设备数据输出，从设备数据输入；<br>  - SCLK（Serial Clock）：时钟信号，由主设备产生；<br>  - CS&#x2F;SS（Chip Select&#x2F;Slave Select）：从设备使能信号，由主设备控制，一主多从时，CS&#x2F;SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。<br><br>  <img src="https://img-blog.csdnimg.cn/6c16b72b4ca04cb389bac848116f8428.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_13,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/6c16b72b4ca04cb389bac848116f8428.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_13,color_FFFFFF,t_70,g_se,x_16"><br><br>  一主设备一从设备模式<br><br>  <img src="https://img-blog.csdnimg.cn/b620a0a2412e4c3792e56a251e760d83.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_18,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/b620a0a2412e4c3792e56a251e760d83.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_18,color_FFFFFF,t_70,g_se,x_16"><br><br>  一主设备多从设备模式<br><br>  # <strong>2、通信原理</strong><br><br>  SPI主设备和从设备都有一个串行移位寄存器，主设备通过向它的SPI串行寄存器写入一个字节来发起一次传输。<br><br>  <img src="https://img-blog.csdnimg.cn/e40c0ec78953486e82fac4fa404f049d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/e40c0ec78953486e82fac4fa404f049d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"><br><br>  SPI数据通信的流程可以分为以下几步：<br><br>  1、主设备发起信号，将CS&#x2F;SS拉低，启动通信。<br><br>  2、主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低），因为SPI有四种模式，后面会讲到），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。<br><br>  3、主机（Master）将要发送的数据写到发送数据缓存区（Menory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。<br><br>  4、从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。<br><br>  例如，下图示例中简单模拟SPI通信流程，主机拉低NSS片选信号，启动通信，并且产生时钟信号，上升沿触发边沿信号，主机在MOSI线路<strong>一位一位</strong>发送数据0X53，在MISO线路<strong>一位一位</strong>接收数据0X46，如下图所示：<br><br>  <img src="https://img-blog.csdnimg.cn/eedf04a26b46483da6d845b3a818512f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/eedf04a26b46483da6d845b3a818512f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"><br><br>  这里有一点需要着重说明一下：<strong>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节（虚拟数据）；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</strong><br><br>  # <strong>3、通信特性</strong><br><br>  ## <strong>3.1、设备选择</strong><br><br>  SPI是单主设备（Single Master）通信协议，只有一支主设备能发起通信，当SPI主设备想读&#x2F;写从设备时，它首先拉低从设备对应的SS线（SS是低电平有效）。接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，主设备把信号发到MOSI实现“写”，同时可对MISO采样而实现“读”。如下图所示：<br><br>  <img src="https://img-blog.csdnimg.cn/a767f5a8f44345838cb27ea7ccc3ce02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/a767f5a8f44345838cb27ea7ccc3ce02.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"><br><br>  ## <strong>3.2、设备时钟</strong><br><br>  SPI时钟特点主要包括：时钟速率、时钟极性和时钟相位三方面。<br><br>  ### <strong>3.2.1、时钟速率</strong><br><br>  SPI总线上的主设备必须在通信开始时候配置并生成相应的时钟信号。从理论上讲，只要实际可行，时钟速率就可以是你想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的SPI传输速率。<br><br>  ### <strong>3.2.2、时钟极性</strong><br><br>  根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据。<br><br>  CKP可以配置为1或0。这意味着你可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。你必须参考设备的数据手册才能正确设置CKP和CKE。<br><br>  - CKP &#x3D; 0：时钟空闲IDLE为低电平 0；<br>  - CKP &#x3D; 1：时钟空闲IDLE为高电平1。<br><br>  ### <strong>3.2.3、时钟相位</strong><br><br>  根据硬件制造商的不同，时钟相位通常写为CKE或CPHA。顾名思义，时钟相位&#x2F;边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；<br><br>  - CKE &#x3D; 0：在时钟信号SCK的第一个跳变沿采样；<br>  - CKE &#x3D; 1：在时钟信号SCK的第二个跳变沿采样。<br><br>  ## <strong>3.3、四种模式</strong><br><br>  根据SPI的时钟极性和时钟相位特性可以设置4种不同的SPI通信操作模式，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低），详情如下所示：<br><br>  - Mode0：CKP&#x3D;0，CKE &#x3D;0：当空闲态时，SCK处于低电平，数据采样是在第1个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在上升沿（准备数据），（发送数据）数据发送是在下降沿。<br>  - Mode1：CKP&#x3D;0，CKE&#x3D;1：当空闲态时，SCK处于低电平，数据发送是在第2个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。<br>  - Mode2：CKP&#x3D;1，CKE&#x3D;0：当空闲态时，SCK处于高电平，数据采集是在第1个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。<br>  - Mode3：CKP&#x3D;1，CKE&#x3D;1：当空闲态时，SCK处于高电平，数据发送是在第2个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。<br><br>  <img src="https://img-blog.csdnimg.cn/20201103011946638.png#pic_center" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20201103011946638.png#pic_center"><br><br>  黑线为采样数据的时刻，蓝线为SCK时钟信号<br><br>  举个例子，下图是SPI Mode0读&#x2F;写时序，可以看出SCK空闲状态为低电平，主机数据在第一个跳变沿被从机采样，数据输出同理。<br><br>  <img src="https://img-blog.csdnimg.cn/99abbf68f67d4d2f81ea11f33057f8b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/99abbf68f67d4d2f81ea11f33057f8b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"><br><br>  下图是SPI Mode3读&#x2F;写时序，SCK空闲状态为高电平，主机数据在第二个跳变沿被从机采样，数据输出同理。<br><br>  <img src="https://img-blog.csdnimg.cn/803592f691cd4196b869e181204950db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/803592f691cd4196b869e181204950db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"><br><br>  # <strong>4、多从机模式</strong><br><br>  有两种方法可以将多个从设备连接到主设备：多片选和菊花链。<br><br>  通常，每个从机都需要一条单独的SS线。如果要和特定的从机进行通讯，可以将相应的<code>NSS</code>信号线拉低，并保持其他SS信号线的状态为高电平；如果同时将两个SS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条<code>MISO</code>线上传输数据，最终导致接收数据乱码。<br><br>  <img src="https://img-blog.csdnimg.cn/b5c18d98920c4e4db32066ed1aead178.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_19,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/b5c18d98920c4e4db32066ed1aead178.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_19,color_FFFFFF,t_70,g_se,x_16"><br><br>  菊花链的最大缺点是信号串行传输，一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了。另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况。<br><br>  <img src="https://img-blog.csdnimg.cn/0f18cc37030a4f06a78f00ee22ed0b69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_19,color_FFFFFF,t_70,g_se,x_16" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/0f18cc37030a4f06a78f00ee22ed0b69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6ISx5Y-R55qE56iL5bqP54y_,size_19,color_FFFFFF,t_70,g_se,x_16"><br><br>  # <strong>5、SPI优缺点</strong><br><br>  - 优点<br>  1. 无起始位和停止位，因此数据位可以连续传输而不会被中断；<br>  2. 没有像I2C这样复杂的从设备寻址系统；<br>  3. 数据传输速率比I2C更高（几乎快两倍）；<br>  4. 分离的MISO和MOSI信号线，因此可以同时发送和接收数据；<br>  5. 极其灵活的数据传输，不限于8位，它可以是任意大小的字；<br>  6. 非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。<br>  - 缺点<br>  1. 使用四根信号线（I2C和UART使用两根信号线）；<br>  2. 无法确认是否已成功接收数据（I2C拥有此功能）；<br>  3. 没有任何形式的错误检查，如UART中的奇偶校验位；<br>  4. 只允许一个主设备；<br>  5. 没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；<br>  6. 没有定义硬件级别的错误检查协议；<br>  7. 与RS-232和CAN总线相比，只能支持非常短的距离；
  </h2><p>  摩托罗拉SPI协议手册：<a target="_blank" rel="noopener" href="https://download.csdn.net/download/m0_38106923/85209714">SPI摩托罗拉协议手册-嵌入式文档类资源-CSDN下载</a></p>
</li>
<li><p>文章总结：SPI定义、DummyByte、片选端</p>
<p>  SPI：Serial Peripheral Interface 串行外设接口；是一种 高速、全双工、同步通信总线；</p>
<p>  谁输出时钟信号，谁就是主机(所以只有一个主机)；</p>
<p>  只有主从机关系，没有接收和被接收关系；主机想要接收数，就得发送一个DummyByte到从机让从机的寄存器把值送入MISO然后进入主机的接收缓存中；</p>
<p>  CS片选端可以选择很多芯片，主要看SPI芯片上的片选端有多少个，如果只有一个可以用菊花链的形式传输数据；</p>
</li>
<li><p>SPI的四种模式：CPOL(clock pole); CPHA(clock phase);</p>
<p>  CPOL(clock pole)时钟极性：极性——&gt;高低</p>
<p>  0 空闲时为低电平</p>
<p>  1 空闲时为高电平</p>
<p>  CPHA(clock phase)时钟相位：相位——&gt;位置 ——&gt;采样位置</p>
<p>  0 在第一个跳变边沿采样</p>
<p>  1 在第二个跳变边沿采样</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2097.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>SPI通信流程【一定要记得有发才有收】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2098.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  按字节发送数据，起始信号之后可以一直发送数据，将字节数据放入缓冲区，然后移位寄存器将缓冲区数据一位一位发出即可；</p>
<p>  拉低CS片选端开始通信 ——&gt; 主机发送SCK告诉从机开始接收(根据四种配置确定采集数据的时机) ——&gt; 主机将缓冲区的数据放入移位寄存器 然后一位一位发出 ——&gt; 从机接收一位一位数据的同时也将其移位寄存器的数据一位一位输出 ——&gt; 从机将缓冲区中数据提取出；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%2099.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  发的同时读：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20100.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1004】SPI读写怎么表示？——看通信流程，发送就将要发送的数据从缓冲区送入移位寄存器；  接收的话就把一个dummyByte送入发送移位寄存器，然后读接收移位寄存器；(发送和接收是同时进行的)</p>
</li>
<li><p>SPI速率怎么理解：</p>
<p>  在STM32中根据APB2总线的时钟速率 除以分配系数得到SPI速度；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20101.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>SPI同步通信、UART异步通信 怎么理解？—— SPI使用时钟，根据这个时钟信号进行数据读写、主从机同步；UART随时都可以收发，只需要约定波特率、起止位等即可；</p>
<p>  您好，这是Bing。我会尽力回答您的问题。😊</p>
<p>  SPI和UART是两种常见的串行通信协议，它们的同步性是指它们在传输数据时是否需要时钟信号来进行同步 。</p>
<ul>
<li>SPI是同步的，因为它需要一个时钟信号来控制数据的发送和接收。SPI通信中，主机会产生一个时钟信号，从机会根据这个时钟信号来读取或者写入数据。这样可以保证主机和从机之间的数据传输是同步的，不会出现数据丢失或者错位的情况 。</li>
<li>UART是异步的，因为它不需要时钟信号来控制数据的发送和接收。UART通信中，发送方和接收方只需要约定好一个波特率，即每秒钟传输多少个位。发送方和接收方各自有一个独立的时钟，用于产生波特率。发送方在每个数据位前后加上一个起始位和一个停止位，用于标识数据的开始和结束。接收方根据起始位和停止位来识别数据，并校验数据的正确性。这样可以实现无时钟信号的数据传输，但是也可能出现时钟偏差或者数据错误的情况 。</li>
</ul>
<p>  希望这能回答您的问题。如果您还有其他问题，欢迎继续提问。😊
  </p>
</li>
<li><p>SPI 优缺点</p>
<ul>
<li>优点</li>
</ul>
<ol>
<li>无起始位和停止位，因此数据位可以连续传输而不会被中断；</li>
<li>没有像I2C这样复杂的从设备寻址系统；</li>
<li>数据传输速率比I2C更高（几乎快两倍）；</li>
<li>分离的MISO和MOSI信号线，因此可以同时发送和接收数据；</li>
<li>极其灵活的数据传输，不限于8位，它可以是任意大小的字；</li>
<li>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。<ul>
<li><p>不需要精密时钟..解析：</p>
<p>  • <strong>不需要精密时钟振荡器&#x2F;晶振</strong>：由于从机使用主机时钟，所以从机不需要自己产生时钟信号，也就不需要精密的时钟振荡器或者晶振来提供稳定的时钟源。这样可以进一步降低硬件成本和功耗。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>缺点【很严重】</li>
</ul>
<ol>
<li>使用四根信号线（I2C和UART使用两根信号线）；</li>
<li>无法确认是否已成功接收数据（I2C拥有此功能）；</li>
<li>没有任何形式的错误检查，如UART中的奇偶校验位；</li>
<li>只允许一个主设备；</li>
<li>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；</li>
<li>没有定义硬件级别的错误检查协议；</li>
<li>与RS-232和CAN总线相比，只能支持非常短的距离；</li>
</ol>
</li>
<li><p>SPI是一种通信协议，可以使用TTL电平或者RS232电平：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20102.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>RS485 RS232 TTL 和 UART IIC SPI CAN有什么关联？——前三个是电气标准，后三个是通信协议，UART特殊一点，是一种硬件接口；</p>
<p>  RS485、RS232、TTL、UART、IIC、SPI和CAN是一些常见的通信方式，它们之间有一些关联和区别，我尝试用简单的语言来解释一下：</p>
<ul>
<li>RS485、RS232和TTL是一些电气标准，它们规定了不同的电平和电压来表示数据的0和1。RS485和RS232使用正负电压来表示数据，而TTL使用高低电平来表示数据。¹²</li>
<li>UART是一种硬件接口，它是通用异步收发传输器的缩写，它可以将并行数据转换成串行数据，或者将串行数据转换成并行数据。UART可以使用RS485、RS232或TTL等电气标准来传输数据，但是需要相应的转换芯片。³⁴</li>
<li>IIC、SPI和CAN是一些通信协议，它们规定了不同的通信规则和格式。IIC和SPI都是同步串行通信协议，它们使用时钟信号来同步数据的传输。CAN是一种控制器局域网协议，它使用差分信号来传输数据，并具有多主多从的网络结构。⁵⁶</li>
<li>IIC、SPI和CAN都可以使用UART作为硬件接口，但是需要相应的控制器或收发器来实现协议的功能。例如，IIC需要一个IIC控制器来生成时钟信号和地址信号，SPI需要一个SPI控制器来生成时钟信号和片选信号，CAN需要一个CAN控制器和一个CAN收发器来实现差分信号的转换和错误检测等功能。</li>
</ul>
<p>  我希望这能够回答你的问题，如果你还有其他关于通信方式的问题，欢迎继续提问。😊</p>
<p>  源: 与必应的对话， 2023&#x2F;9&#x2F;20<br>  (1) IIC、SPI、USART、RS485、RS232、CAN外设通信总结 - 知乎. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/548567587">https://zhuanlan.zhihu.com/p/548567587</a>.<br>  (2) 简单几句讲明白UART、COM、485、RS232、I2C、SPI区分_uart和com区别_DLluop的博客-CSDN博客. <a target="_blank" rel="noopener" href="https://blog.csdn.net/luopeng12345/article/details/108885032">https://blog.csdn.net/luopeng12345/article/details/108885032</a>.<br>  (3) TTL、RS232、RS485、CAN、IIC几种常见的通讯协议简介_ttl协议_lsh_sharon的博客-CSDN博客. <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41092963/article/details/85017051">https://blog.csdn.net/qq_41092963&#x2F;article&#x2F;details&#x2F;85017051</a>.<br>  (4) 常见通信方式（TTL、RS232、RS485、CAN）总结 - 知乎. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/456827469">https://zhuanlan.zhihu.com/p/456827469</a>.<br>  (5) undefined. <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_31898831/article/details/112115192">https://blog.csdn.net/weixin_31898831&#x2F;article&#x2F;details&#x2F;112115192</a>.<br>  (6) undefined. <a target="_blank" rel="noopener" href="https://blog.csdn.net/fpga_verilog_sky/article/details/103525706">https://blog.csdn.net/fpga_verilog_sky&#x2F;article&#x2F;details&#x2F;103525706</a>.
  </p>
</li>
<li><p>【1009】IIC、SPI 主从机怎么判断？SPI——时钟产生者；IIC——起始位终止位产生者：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20103.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>【1104】IIC从机不能主动发送消息给主机； SPI从机也不能主动发送；</p>
</li>
<li><p>DMA</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DMA是什么？<br>为什么要用DMA？<br>DMA的实现机制是怎么样的？<br>DMA与中断的比较<br></code></pre></td></tr></table></figure>
<ul>
<li>DMA Direct Memory Access 直接内存访问；不需要CPU搬运数据，直接用外设将寄存器、内存的数据搬运到指定位置；减轻CPU负担；</li>
<li></li>
</ul>
</li>
<li><p>ADC&#x2F;DAC</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">什么是ADC？<br>ADC是怎么实现的？<br>ADC种类有哪些？<br>ADC获取的数据有哪些处理、滤波方法？<br>ADC时钟由谁提供？<br></code></pre></td></tr></table></figure>
<ul>
<li><p>一定要好好看的ADC文：——逐次比较型ADC原理：首先逐次逼近寄存器根据VREF控制DAC输出，然后到放大器跟输入电压进行比较，如果输入电压大于DAC输出电压则这一位1保留，继续判断下一位的1，看看加上之后效果；</p>
<h1 id="ADC的基本工作原理-adc原理-CSDN博客"><a href="#ADC的基本工作原理-adc原理-CSDN博客" class="headerlink" title="ADC的基本工作原理_adc原理-CSDN博客"></a><strong>ADC的基本工作原理_adc原理-CSDN博客</strong></h1><p>  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/xtmtm/article/details/107708053">blog.csdn.net**&#x2F;xtmtm&#x2F;article&#x2F;details&#x2F;107708053</a></p>
<p>  <a target="_blank" rel="noopener" href="https://g.csdnimg.cn/static/logo/favicon32.ico">https://g.csdnimg.cn/static/logo/favicon32.ico</a></p>
<h2 id="ADC（analog-to-digital-converter）的转换过程"><a href="#ADC（analog-to-digital-converter）的转换过程" class="headerlink" title="ADC（analog to digital converter）的转换过程"></a><strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ADC&spm=1001.2101.3001.7020">ADC</a>（analog to digital converter）的转换过程</strong></h2><p>  ADC的基本转换原理分为四个过程：</p>
<p>  ①抗混叠滤波（Anti-aliasing），可以理解为一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8&spm=1001.2101.3001.7020">低通滤波器</a></p>
<p>  ②采样保持电路（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Sample&spm=1001.2101.3001.7020">Sample</a> and hold）</p>
<p>  ③量化（Quantizer）</p>
<p>  ④编码（Coder）</p>
<p>  <strong>采样保持</strong></p>
<p>  所谓采样就是将一个时间上<strong>连续</strong>变化的<strong>模拟量</strong>转化为时间上<strong>离散</strong>变化的<strong>模拟量</strong>。将采样结果储存起来，直到下次采样，这个过程叫作<strong>保持</strong>。</p>
<p>  <strong>量化和编码</strong></p>
<p>  模拟信号通过ADC转换成数字信号的这一过程称为<strong>量化</strong>，由于量化输出的数字信号位数有限，所以输出的数字信号和你采样得到的模拟信号会有一个误差，被称为<strong>量化误差</strong>,对于一个N位ADC来说，假设其满量程电压为Vref，Vref被ADC分为2N个区间，区间宽度用LSB（last significant bit）表示<strong>LSB&#x3D;Vref&#x2F;2N</strong>。</p>
<p>  例如：Vref&#x3D;8V，ADC为3位，LSB&#x3D;1，所以每个区间为1V，</p>
<p>  000代表电压0≤V＜1</p>
<p>  001代表电压1≤V＜2</p>
<p>  010代表电压2≤V＜3</p>
<p>  011代表电压3≤V＜4</p>
<p>  100代表电压4≤V＜5</p>
<p>  101代表电压5≤V＜6</p>
<p>  110代表电压6≤V＜7</p>
<p>  111代表电压7≤V＜8</p>
<p>  此ADC的分辨率为1V</p>
<p>  <img src="https://img-blog.csdnimg.cn/2020073111090647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/2020073111090647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70"></p>
<h2 id="ADC的分类"><a href="#ADC的分类" class="headerlink" title="ADC的分类"></a><strong>ADC的分类</strong></h2><p>  ①逐次比较型ADC</p>
<p>  基本原理是从高位到低位逐位试探比较，好像用天平称物体，从重到轻逐级增减砝码进行试探。逐次逼近法转换过程是：初始化时将逐次逼近寄存器各位清零；转换开始时，先将逐次逼近寄存器最高位置1，送入D&#x2F;A转换器，经D&#x2F;A转换后生成的模拟量送入比较器，称为 Vo，与送入比较器的待转换的模拟量Vi进行比较，若Vo&lt;Vi，该位1被保留，否则被清除。然后再置逐次逼近寄存器次高位为1，将寄存器中新的数字量送D&#x2F;A转换器，输出的 Vo再与Vi比较，若Vo&lt;Vi，该位1被保留，否则被清除。重复此过程，直至逼近寄存器最低位。转换结束后，将逐次逼近寄存器中的数字量送入缓冲寄存器，得到数字量的输出。</p>
<p>  <img src="https://img-blog.csdnimg.cn/2020080309141094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/2020080309141094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70"></p>
<p>  ②双积分式ADC</p>
<p>  基本原理是将输入电压变换成与其平均值成正比的时间间隔，再把时间间隔转换成数字量，属于间接转换。转换过程是：先将开关接通待转换的模拟量Vi，Vi采样输入到积分器，积分器从零开始固定时间T的正向积分，时间T到后，开关再接通与Vi极性相反的基准电压Vref，将Vref输入到积分器进行反向积分，直到输出位0V时停止积分。Vi越大，积分器输出电压越大，反向积分时间也越长。计数器在反向积分时间内所计的数值，就是模拟电压Vi所对应的数字量，实现了A&#x2F;D转换。</p>
<p>  <img src="https://img-blog.csdnimg.cn/20200803092737290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20200803092737290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0bXRt,size_16,color_FFFFFF,t_70"></p>
<p>  ③全并行&#x2F;串并行ADC</p>
<h2 id="ADC的参数"><a href="#ADC的参数" class="headerlink" title="ADC的参数"></a><strong>ADC的参数</strong></h2><p>  ①分辨率</p>
<p>  数字量变化一个最小量时模拟信号的变化量，定义为满刻度与2n的比值，通常以数字信号的位数来表示。</p>
<p>  ②转换速率</p>
<p>  转换速率是指A&#x2F;D转换一次所需要时间的倒数，即单位时间内完成A&#x2F;D转换的次数</p>
<p>  ③采样速率</p>
<p>  采样速率是两次采样（两次转换）的间隔时间的倒数，为了保证转换的正确完成，一般采样速率必须小于等于转换速率，即采样时间大于等于转换时间。</p>
<p>  [1]胡任任. 一种8通道12位1MS&#x2F;s SAR ADC的设计[D].电子科技大学,2020.</p>
<p>  [2]张卿杰，徐友. 手把手教你学DSP——基于TMS320F28335（第二版）[M].北京：北京航空航天大学出版社，2018.</p>
</li>
</ul>
</li>
<li><p>CAN总线、L:IN总线？</p>
<p>  CAN总线是一种多主机多从机的去中心化的全双工的通信总线；</p>
<p>  LIN总线是单主机多从机的通信总线；</p>
<ul>
<li><p>CAN总线参考：</p>
<p>  <strong><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32221140?utm_campaign=&utm_medium=social&utm_oi=681153646197215232&utm_psn=1687804950611222528&utm_source=zhihu">一口气从零读懂CAN总线，</a></strong></p>
</li>
<li><p>CAN总线物理层，线与(仲裁机制)，差分信号，高速低速接法，传输速度40M内1Mbps；</p>
<p>  线与机制和IIC总线差不多，谁先出现低电平谁就先抢占总线；</p>
<ul>
<li><p>CAN总线仲裁机制解析: 显性电平(0)，总是会掩盖隐性电平；跟IIC一样，逻辑0会占据总线；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20104.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
<p>  差分信号：CAN_TN  CAN_RX 电压差值在0.5V以下是隐性电平，表示1；压差在0.9V以上是显性电平，表示0；</p>
<p>  低速接法，总线开环，TXRX线上接2.2k电阻；</p>
<p>  高速接法，总线闭环，总线头尾接一个100Ω电阻；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20105.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  传输速度：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20106.png" srcset="/img/loading.gif" lazyload alt="Untitled">
  </p>
</li>
<li><p>【重要】CAN总线：优点、CAN节点构成、CAN协议、CAN寻址、CAN仲裁</p>
<p>  CAN总线多主机多从机的机制，去中心化，保证安全性；只需要两根线通信，减少了布线的难度；基于消息广播机制；</p>
<ul>
<li><p>寻址机制：节点没有地址，而是消息带有标识符(Identifier)，节点会监听总线上的数据帧，看看这个标识符是否符合接收；</p>
<p>  不同于其它类型的总线，<strong>CAN总线不设定节点的地址，而是通过消息的标识符（Identifier）来区别消息</strong>。CAN总线消息是广播式的，也就是说在同一时刻所有节点都检测到同样的电平信号。</p>
<p>  接受节点通过识别消息中的标识符，与该节点预设的过滤规则对比，如果满足规则就接收这条消息，发送应答，否则就忽略这条消息，关于这部分介绍见下文“<strong>条件接收</strong>”部分。</p>
<p>  这种机制虽然会增加消息帧的复杂度（增加标识符），但是节点在此情况下可以无须了解其它节点的状况，而相互间独立工作，在总线上增加节点时仅须关注消息类型，而非系统上其它节点的状况。这种<strong>以消息标识符寻址的方式</strong>，让在总线上增加节点变得更加灵活。</p>
</li>
<li><p>CAN节点构成：MCU&#x2F;CPU  +  CAN控制器  +  CAN收发器</p>
</li>
<li><p>数据帧结构以及要点：仲裁段、控制段、数据段：</p>
<ul>
<li><p>参考：</p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/642685125">https://zhuanlan.zhihu.com/p/642685125</a></p>
</li>
</ul>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20107.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<ul>
<li><p>各段的大致描述以及所占的位：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">SOF：表示数据帧开始；（<span class="hljs-number">1</span> bit）<br>Identifier：标准格式<span class="hljs-number">11</span> bit，扩展格式<span class="hljs-number">29</span> bit包括Base Identifier（<span class="hljs-number">11</span> bit）和Extended Identifier（<span class="hljs-number">18</span> bit），该区段标识数据帧的优先级，数值越小，优先级越高；<br>RTR：远程传输请求位，<span class="hljs-number">0</span>时表示为数据帧，<span class="hljs-number">1</span>表示为远程帧，也就是说RTR=<span class="hljs-number">1</span>时，消息帧的Data Field为空；（<span class="hljs-number">1</span> bit）<br>IDE：标识符扩展位，<span class="hljs-number">0</span>时表示为标准格式，<span class="hljs-number">1</span>表示为扩展格式；（<span class="hljs-number">1</span> bit）<br>DLC：数据长度代码，<span class="hljs-number">08</span>表示数据长度为<span class="hljs-number">08</span> Byte；（<span class="hljs-number">4</span> bit）<br>Data Field：数据域；（<span class="hljs-number">0</span>~<span class="hljs-number">8</span> Byte）<br>CRC Sequence：校验域，校验算法G(x) = x15 + x14 + x10 + x8 + x7 + x4 + x3 + <span class="hljs-number">1</span>；（<span class="hljs-number">15</span> bit）<br>DEL：校验域和应答域的隐性界定符；（<span class="hljs-number">1</span> bit）<br>ACK：应答，确认数据是否正常接收，所谓正常接收是指不含填充错误、格式错误、 CRC 错误。发送节点将此位为<span class="hljs-number">1</span>，接收节点正常接收数据后将此位置为<span class="hljs-number">0</span>；（<span class="hljs-number">1</span> bit）<br>SRR：替代远程请求位，在扩展格式中占位用，必须为<span class="hljs-number">1</span>；（<span class="hljs-number">1</span> bit）<br>EOF：连续<span class="hljs-number">7</span>个隐性位（<span class="hljs-number">1</span>）表示帧结束；（<span class="hljs-number">7</span> bit）<br>ITM：帧间空间，Intermission (ITM)，又称Interframe Space (IFS)，连续<span class="hljs-number">3</span>个隐性位，但它不属于数据帧。帧间空间是用于将数据帧和远程帧与前面的帧分离开来的帧。数据帧和远程帧可通过插入帧间空间将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。过载帧和错误帧前不能插入帧间空间。<br></code></pre></td></tr></table></figure>
</li>
<li><p>数据帧的起始和结束位：起始位由一个显性位构成，结束位由七个隐性位构成：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20108.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p><strong>仲裁段</strong>：包含ID和Extended ID；线与机制；【ID越小也就是显性电平(0)越多，那么消息优先级就越高】</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20109.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  仲裁段结论：</p>
<ul>
<li><strong>从该分析过程得出结论是：帧ID值越小，优先级越高</strong></li>
<li><strong>对于同为扩展格式数据帧、标准格式远程帧和扩展格式远程帧的情况同理。</strong></li>
</ul>
</li>
<li><p>CAN仲裁与IIC仲裁的区别：I2C消息本身不带优先级，但是CAN的消息是带的；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20110.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p><strong>控制段</strong>：最重要的就是DLC，规定了数据段中的数据字节数 0~8个字节：</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20111.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p><strong>数据段</strong>：要注意的是 数据段字节是 MSB 还是 LSB；报文数据量小，传输效率高，抗干扰能力强；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20112.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ul>
</li>
<li><p>远程帧、错误帧、过载帧的通俗描述以及定义：</p>
<p>  通俗描述：</p>
<p>  我尽量用通俗的语言来解释一下CAN总线中的远程帧、错误帧、过载帧的作用吧。</p>
<ul>
<li>远程帧：就像是一个电话，你可以打给别人，问他有没有你想要的信息，比如温度、速度等。如果他有，他就会回答你，把信息告诉你。</li>
<li>错误帧：就像是一个警报，当你发现总线上有什么不对劲的时候，你就会发出一个错误帧，让其他人都知道发生了什么事情，比如数据错了、格式错了、没人回答你等。 然后你和其他人都会根据错误的严重程度，决定是不是要暂停通信，或者重新开始通信。</li>
<li>过载帧：就像是一个暂停键，当你觉得自己还没准备好接收下一个信息的时候，你就会发出一个过载帧，让其他人都等一等，不要急着给你发信息。 等你准备好了，你就会继续通信。</li>
</ul>
<p>  这样你能明白吗？如果你还有其他问题，我很乐意回答。😊</p>
<p>  CAN总线中的远程帧、错误帧、过载帧是三种不同的帧类型，它们的作用分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343607068">远程帧：用于请求其他节点发送具有同一标识符的数据帧。例如，如果节点A需要节点B的温度数据，它可以发送一个远程帧，包含节点B的温度数据的标识符。然后节点B收到这个远程帧后，就会发送一个数据帧，包含它的温度数据。1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66040930">2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43147243/article/details/121923573">错误帧：用于表示某个节点检测到了总线上的错误，例如CRC错误、格式错误、应答错误等。3</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/649366078">错误帧由两个部分组成：错误标志和错误界定符。错误标志是由6个或更多的连续显性位组成，用于通知其他节点发生了错误。错误界定符是由8个隐性位组成，用于结束错误帧。4</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43147243/article/details/121851395">当一个节点发送或接收到一个错误帧后，它会进入一种错误状态，根据错误的严重程度，可能会暂时或永久地停止发送或接收数据。5</a></li>
<li>过载帧：用于表示某个节点没有准备好接收下一个数据帧或远程帧，需要延迟一段时间。 过载帧由两个部分组成：过载标志和过载界定符。过载标志是由6个连续显性位组成，用于请求其他节点暂停发送。过载界定符是由8个隐性位组成，用于结束过载帧。 当一个节点发送或接收到一个过载帧后，它会在下一个互斥位之前等待一段时间，然后再继续发送或接收数据。</li>
</ul>
<p>  我希望这能够回答你的问题，如果你还有其他关于CAN总线的问题，欢迎继续提问。😊</p>
</li>
</ul>
</li>
<li><p>【拓展】CANopen是什么？和CAN的关系是什么？——CAN只负责数据链路层和物理层接受数据和错误检测但是不负责数据内容，CANopen就是在这之上的应用层描述了数据报文的含义；</p>
<p>  CANopen是一种基于CAN总线的高层软件通信协议，它是一种用于嵌入式系统和工业控制的现场总线协议。1<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107874529">2</a> CANopen定义了一些通信和设备的规范，使得不同厂商的设备可以通过CANopen协议进行数据交换和配置。<a target="_blank" rel="noopener" href="https://www.sohu.com/a/482438867_121124496">3</a></p>
<p>  CANopen和CAN的关系是，CANopen是在CAN的物理层和数据链路层之上，增加了应用层和网络层的协议。<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/294055889.html">4</a> CAN是一种控制器局域网，它是德国博世公司开发的一种用于汽车控制的现场总线。5 CAN只负责数据的传输和错误检测，不涉及数据的含义和格式。 CANopen则规定了数据的结构、编码、标识符、对象字典等，使得数据具有可读性和互操作性。</p>
<p>  简单来说，CANopen是在CAN的基础上开发的一种应用层协议，它是对CAN总线通信的一种统一规范，适合于运动控制和其他自动化领域。 CAN相当于电话机和传输介质的定义，不管有线或无线，CANopen定义了语言。</p>
<p>  我希望这能够回答你的问题，如果你还有其他关于CANopen或CAN的问题，欢迎继续提问。😊</p>
</li>
</ul>
</li>
<li><p>Modbus</p>
</li>
<li><p>定时器</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">定时器的特殊工作模式有哪些？<br>定时器PWM？<br>如何实现PWM调速？<br>定时器中断？<br></code></pre></td></tr></table></figure>
</li>
<li><p>bootloader具体做了什么？——&gt; (通过UART、USB_DFU)烧写程序到Flash中；检查Flash中是否有应用程序，并跳转到程序中运行【引导跳转】；检查芯片的参数、ID、Flash大小；</p>
<p>  您好，这是Bing。我很高兴为您解答关于STM32 BootLoader的问题。😊</p>
<p>  STM32 BootLoader是一种用于更新或加载应用程序的程序，它可以通过UART、USB、CAN等接口接收数据，并将其写入Flash中¹。STM32 BootLoader的主要功能有以下几点²：</p>
<ul>
<li>在芯片启动时，根据BOOT引脚或选项字节的设置，决定是从系统存储器（内置的BootLoader）还是主Flash（用户的应用程序）中执行代码²。</li>
<li>如果从系统存储器中执行代码，那么根据不同的外设接口，进入不同的BootLoader模式，例如USB DFU、UART IAP等²。</li>
<li>在BootLoader模式下，与外部的上位机通信，接收上位机发送的命令和数据，并对Flash进行擦写、读写、保护等操作²。</li>
<li>在BootLoader模式下，检测是否有有效的应用程序存在于主Flash中，如果有，那么跳转到应用程序执行²。</li>
<li>在BootLoader模式下，提供一些系统信息和状态，例如芯片ID、Flash大小、选项字节值等²。</li>
</ul>
<p>  Flash的大小是512MB ，0x7ffff → 0x80000  → 2^3<em>2</em>16 &#x3D; 2^19 &#x3D; 512MB</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20113.png" srcset="/img/loading.gif" lazyload alt="Untitled">
  </p>
</li>
<li><p>.s 启动文件不是BootLoader .s 启动文件都做了些什么? ——&gt;  _initial_sp; Reset_Handler; 最后进入main 【<a target="_blank" rel="noopener" href="https://www.notion.so/STM32-1-ad61c27b3f4e4a1abb355724c93e2a98?pvs=21">复习一下上电启动流程——&gt;</a>】</p>
<p>  您好，这是Bing。我很高兴为您解答关于STM32 .s 启动文件的问题。😊</p>
<p>  STM32 .s 启动文件是一种汇编语言文件，用于启动STM32系列微控制器。它的主要功能有以下几点¹²：</p>
<ul>
<li>初始化堆栈指针 SP&#x3D;_initial_sp，用于存储局部变量，函数调用，函数形参等。</li>
<li>初始化 PC指针&#x3D;Reset_Handler，用于跳转到复位中断服务程序。</li>
<li>初始化中断向量表，用于存储各种异常和中断的入口地址。</li>
<li>配置系统时钟，用于设置系统的工作频率和时钟源。</li>
<li>调用 C库函数_main 初始化用户堆栈，从而最终调用 main 函数去到 C的世界。</li>
</ul>
<p>  启动文件的具体内容和格式可能根据不同的STM32型号和编译器而有所差异，但基本的逻辑和结构是相同的。您可以在开发环境中查看或修改启动文件，也可以在网上找到相关的教程和示例³。
  </p>
</li>
<li><p>什么是交叉编译？为什么要交叉编译</p>
<p>  交叉编译即一个平台编译出另一个平台才能跑的程序；</p>
<p>  因为某些平台资源太少，无法编译出自己所需要的程序；</p>
</li>
<li><p>单片机main函数之前做了什么工作？</p>
<p>  <a href="%E3%80%90%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E5%88%B7%E9%A2%98&%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E3%80%91%209536a649e3cf4c5f905a2222e6ae6219.md">看上面 .s启动 文件功能；</a></p>
</li>
<li></li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li><p>NAND FLASH和NOR FLASH的区别？</p>
<p>  NOR Flash主要用于单片机程序的存储器；NAND用于SSD固态硬盘。</p>
<p>  NOR Flash的特点就是芯片内执行，应用程序可以直接在Flash中运行，不必加载到RAM中，比如BootLoader，CPU直接通过读取Flash中的BootLoader程序启动芯片，然后把操作系统从Flash加载到RAM中运行。用于在1~4MB类似的小容量存储。价格高，而NAND价格低；</p>
<p>  NOR Flash擦除写入的速度很慢(5s)，想想ARM芯片烧录时的速度就知道。而NAND Flash只有5ms，擦写速度很快。</p>
<p>  NAND 的擦写次数 ： NOR Flash 擦写次数 &#x3D; 10 ： 1</p>
<ul>
<li><p>文章：</p>
<h1 id="嵌入式开发之Nand-Flash和Nor-Flash的区别"><a href="#嵌入式开发之Nand-Flash和Nor-Flash的区别" class="headerlink" title="嵌入式开发之Nand-Flash和Nor-Flash的区别"></a><strong>嵌入式开发之Nand-Flash和Nor-Flash的区别</strong></h1><p>  **<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45244289/article/details/118601493">blog.csdn.net**&#x2F;weixin_45244289&#x2F;article&#x2F;details&#x2F;118601493</a></p>
<p>  <a target="_blank" rel="noopener" href="https://g.csdnimg.cn/static/logo/favicon32.ico">https://g.csdnimg.cn/static/logo/favicon32.ico</a></p>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45244289/category_10594213.html">嵌入式开发学习笔记 专栏收录该内容</a></p>
<p>  <img src="https://img-blog.csdnimg.cn/20201014180756916.png?x-oss-process=image/resize,m_fixed,h_64,w_64" srcset="/img/loading.gif" lazyload alt="https://img-blog.csdnimg.cn/20201014180756916.png?x-oss-process=image/resize,m_fixed,h_64,w_64"></p>
<p>  11 篇文章 4 订阅</p>
<p>  订阅专栏</p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a><strong>一、引言</strong></h1><p>  在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>开发中，想来每一个嵌入式开发工程师不可避免地都会听到或者接触到Flash这个东西。</p>
<p>  但是对于一部分人来说，他们并不清楚Flash还有Nand和Nor之分，因此就更不清楚这两者的区别了。</p>
<p>  今天偶然想起这个问题，于是查询资料，写下这篇博客，做个简单的笔记。</p>
<h1 id="二、Flash介绍"><a href="#二、Flash介绍" class="headerlink" title="二、Flash介绍"></a><strong>二、Flash介绍</strong></h1><p>  FLASH是一种存储芯片，全名叫Flash Eeprom Memory，通过程序可以修改数据，即平时所说的“闪存”。Flash又分为Nand-Flash和Nor-Flash二种。U盘和MP3里用的就是这种存储器。</p>
<h2 id="2-1、Nand-Flash"><a href="#2-1、Nand-Flash" class="headerlink" title="2.1、Nand-Flash"></a><strong>2.1、Nand-Flash</strong></h2><p>  Nand-Flash内存是Flash内存的一种，1989年，东芝公司发表了Nand-Flash结构。其内部采用非线性宏单元模式，为固态大容量内存的实现提供了廉价有效的解决方案。</p>
<p>  NAND-Flash 没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取 512 个字节，采用这种技术的Flash比较廉价。因此，Nand-flash存储器容量较大、改写速度快等优点，使其成大量数据存储市场的宠儿。</p>
<h2 id="2-2、Nor-Flash"><a href="#2-2、Nor-Flash" class="headerlink" title="2.2、Nor-Flash"></a><strong>2.2、Nor-Flash</strong></h2><p>  Nor-Flash是Intel公司1988年开发出了Nor-Flash技术。Nor-Flash的特点是芯片内执行（XIP, eXecute In Place），这样应用程序可以直接在Flash闪存内运行，不必再把代码读到系统Ram中。</p>
<p>  Nor-Flash的传输效率很高，在1～4MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能，因此Nor-Flash只能用于特定的场合，比如作为Arm板启动代码的载体。</p>
<h1 id="三、Nand-Flash和Nor-Flash的区别"><a href="#三、Nand-Flash和Nor-Flash的区别" class="headerlink" title="三、Nand-Flash和Nor-Flash的区别"></a><strong>三、Nand-Flash和Nor-Flash的区别</strong></h1><h2 id="3-1、性能比较"><a href="#3-1、性能比较" class="headerlink" title="3.1、性能比较"></a><strong>3.1、性能比较</strong></h2><p>  Flash闪存是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。</p>
<p>  任何Flash器件的写入操作只能在空或已擦除的单元内进行，所以大多数情况下，在进行写入操作之前必须先执行擦除。</p>
<p>  Nand-Flash器件执行擦除操作是十分简单的，而Nor-Flash则要求在进行擦除前先要将目标块内所有的位都写为0。由于擦除Nor-Flash器件时是以64～128KB的块进行的，执行一个写入&#x2F;擦除操作的时间为5s，与此相反，擦除Nand-Flash器件是以8～32KB的块进行的，执行相同的操作最多只需要4ms。</p>
<p>  执行擦除时，块尺寸的不同进一步拉大了Nor-Flash和Nand-Flash之间的性能差距。统计表明，对于给定的一套写入操作(尤其是更新小文件时)，更多的擦除操作必须在基于Nor-Flash的单元中进行。这样，当选择存储解决方案时，设计师就必须权衡以下的各项因素：</p>
<p>  1、Nor-Flash的读速度比Nand-Flash稍快一些；</p>
<p>  2、Nand-Flash的写入速度比Nor-Flash快很多；</p>
<p>  3、Nand-Flash的4ms擦除速度远比Nor-Flash的5s快；</p>
<p>  4、大多数写入操作需要先进行擦除操作；</p>
<p>  5、Nand-Flash的擦除单元更小，相应的擦除电路更少。</p>
<h2 id="3-2、接口差别"><a href="#3-2、接口差别" class="headerlink" title="3.2、接口差别"></a><strong>3.2、接口差别</strong></h2><p>  Nor-Flash带有Sram接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。</p>
<p>  Nand-Flash器件使用复杂的I&#x2F;O口来串行地存取数据，各个产品或厂商的方法可能各不相同。8个引脚用来传送控制、地址和数据信息。</p>
<p>  Nand-Flash读和写操作采用512字节的块，这一点有点像硬盘管理此类操作，很自然地，基于Nand-Flash的存储器就可以取代硬盘或其他块设备。</p>
<h2 id="3-3、容量和成本"><a href="#3-3、容量和成本" class="headerlink" title="3.3、容量和成本"></a><strong>3.3、容量和成本</strong></h2><p>  Nand-Flash的单元尺寸几乎是Nor-Flash器件的一半，由于生产过程更为简单，Nand-Flash结构可以在给定的模具尺寸内提供更高的容量，也就相应地降低了价格。</p>
<p>  Nor-Flash占据了容量为1～16MB闪存市场的大部分，而Nand-Flash只是用在8～128MB的产品当中，这也说明Nor-Flash主要应用在代码存储介质中，Nand-Flash适合于数据存储，Nand-Flash在CompactFlash、Secure Digital、PC Cards和MMC存储卡市场上所占份额最大。</p>
<h2 id="3-4、可靠性和耐用性"><a href="#3-4、可靠性和耐用性" class="headerlink" title="3.4、可靠性和耐用性"></a><strong>3.4、可靠性和耐用性</strong></h2><p>  采用Flash介质时一个需要重点考虑的问题是可靠性。</p>
<p>  对于需要扩展MTBF的系统来说，Flash是非常合适的存储方案。可以从寿命(耐用性)、位交换和坏块处理三个方面来比较Nor-Flash和Nand-Flash的可靠性。</p>
<p>  在Nand-Flash闪存中每个块的最大擦写次数是一百万次，而Nor-Flash的擦写次数是十万次。Nand-Flash存储器除了具有10比1的块擦除周期优势，典型的Nand-Flash块尺寸要比Nor-Flash器件小8倍，每个Nand-Flash存储器块在给定的时间内的删除次数要少一些。</p>
<h1 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a><strong>四、补充</strong></h1><h2 id="4-1、位交换"><a href="#4-1、位交换" class="headerlink" title="4.1、位交换"></a><strong>4.1、位交换</strong></h2><p>  所有Flash器件都受位交换现象的困扰。在某些情况下(很少见，Nand-Flash发生的次数要比Nor-Flash多)，一个比特位会发生反转。一位的变化可能不很明显，但是如果发生在一个关键文件上，这个小小的故障可能导致系统停机。</p>
<p>  如果只是报告有问题，多读几次就可能解决了。当然，如果这个位真的改变了，就必须采用错误探测&#x2F;错误更正(EDC&#x2F;ECC)算法。</p>
<h2 id="4-2、坏块处理"><a href="#4-2、坏块处理" class="headerlink" title="4.2、坏块处理"></a><strong>4.2、坏块处理</strong></h2><p>  Nand-Flash器件中的坏块是随机分布的。以前也曾有过消除坏块的努力，但发现成品率太低，代价太高，根本不划算。</p>
<p>  Nand-Flash器件需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用。在已制成的器件中，如果不能通过可靠的方法进行这项处理，将导致高故障率。</p>
</li>
</ul>
</li>
<li><p>基于ROM的运行方式和基于RAM的运行方式有什么区别？</p>
<p>  是的，从NOR Flash中读取数据执行是基于ROM的运行方式¹。基于ROM的运行方式和基于RAM的运行方式的区别主要有以下几点²³：</p>
<ul>
<li>基于ROM的运行方式是指程序代码存储在ROM中，CPU可以直接从ROM中取指令执行，不需要将代码复制到RAM中。这种方式节省了RAM空间，但是速度较慢，因为ROM的读写速度一般低于RAM²。</li>
<li>基于RAM的运行方式是指程序代码必须先加载到RAM中，然后CPU从RAM中取指令执行。这种方式占用了RAM空间，但是速度较快，因为RAM的读写速度一般高于ROM²。</li>
<li>基于ROM的运行方式适合用于存储固定不变或者不经常变化的程序代码，例如启动代码、操作系统内核、固件等²。基于RAM的运行方式适合用于存储动态变化或者经常变化的程序代码，例如应用程序、用户数据等²。</li>
<li><strong>基于ROM的运行方式需要在编译时确定程序代码的地址，因此不支持动态链接和加载³</strong>。基于RAM的运行方式可以在运行时确定程序代码的地址，因此支持动态链接和加载³。</li>
</ul>
<p>  <strong>但是单片机不一定是纯基于ROM或者RAM执行：</strong></p>
<p>  不一定，STM32 8051 这样的单片机芯片可以选择是基于ROM方式还是基于RAM方式运行程序。基于ROM方式是指程序代码存储在ROM中，CPU可以直接从ROM中取指令执行，不需要将代码复制到RAM中。基于RAM方式是指程序代码必须先加载到RAM中，然后CPU从RAM中取指令执行。这两种方式各有优缺点，具体要根据程序的需求和存储器的性能来选择。
  </p>
</li>
<li><p>arm有几个寄存器？什么是CPSR，SPSR？什么时候用到？</p>
</li>
<li><p>通用寄存器包括R0～R15，可以分为具体哪三类？</p>
</li>
<li><p>PC寄存器的作用是什么？——指向当前或下一条指令。【stm32是指向当前语句地址】</p>
<p>  “PC寄存器是一种特殊的寄存器，它的全称是Program Counter，也叫指令计数器或指令指针。它的作用是存储当前正在执行的指令的地址，或者下一条要执行的指令的地址”</p>
<p>  内核架构不同导致的执行方式不同。</p>
</li>
<li><p>ISP ICP IAP OTA是什么？通过无线升级固件的技术；</p>
<p>  <a target="_blank" rel="noopener" href="https://www.notion.so/3-ISP-ICP-IAP-29449768d94e4b99ae81455c4bcaff70?pvs=21">前三个指路——&gt;</a></p>
<p>  OTA : Over-the-air 空中下载技术；通过无线升级固件的技术；</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/Untitled%20114.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>malloc&#x2F;free原理</p>
<h2 id="https-zhuanlan-zhihu-com-p-384022573-malloc原理-空闲链表-整块分配-不是唯一的方法-【方法2是-空闲链表-按需分配】-malloc-的实现方式一：显式空闲链表-整块分配-malloc-的实现方式有很多种。最简单的方法是使用一个链表来管理所有已分配和未分配的内存块，在每个内存块的首部记录当前块的大小、当前区块是否已经被分配出去。首部对应这样的结构体：-使用首次适应法进行分配：遍历整个链表，找到第一个未被分配、大小合适的内存块；如果没有这样的内存块，则向操作系统申请扩展堆内存。-源码-这个-方法的缺陷：-这种方法的缺点是：-1-已分配和未分配的内存块位于同一个链表中，每次分配都需要从头到尾遍历-2-采用首次适应法，内存块会被整体分配，容易产生较多内部碎片-看看newbing怎么说"><a href="#https-zhuanlan-zhihu-com-p-384022573-malloc原理-空闲链表-整块分配-不是唯一的方法-【方法2是-空闲链表-按需分配】-malloc-的实现方式一：显式空闲链表-整块分配-malloc-的实现方式有很多种。最简单的方法是使用一个链表来管理所有已分配和未分配的内存块，在每个内存块的首部记录当前块的大小、当前区块是否已经被分配出去。首部对应这样的结构体：-使用首次适应法进行分配：遍历整个链表，找到第一个未被分配、大小合适的内存块；如果没有这样的内存块，则向操作系统申请扩展堆内存。-源码-这个-方法的缺陷：-这种方法的缺点是：-1-已分配和未分配的内存块位于同一个链表中，每次分配都需要从头到尾遍历-2-采用首次适应法，内存块会被整体分配，容易产生较多内部碎片-看看newbing怎么说" class="headerlink" title="  https://zhuanlan.zhihu.com/p/384022573  - malloc原理 空闲链表 整块分配(不是唯一的方法) 【方法2是 空闲链表+按需分配】      ### malloc 的实现方式一：显式空闲链表 + 整块分配      malloc 的实现方式有很多种。最简单的方法是使用一个链表来管理所有已分配和未分配的内存块，在每个内存块的首部记录当前块的大小、当前区块是否已经被分配出去。首部对应这样的结构体：            使用首次适应法进行分配：遍历整个链表，找到第一个未被分配、大小合适的内存块；如果没有这样的内存块，则向操作系统申请扩展堆内存。      源码        - 这个 方法的缺陷：      这种方法的缺点是：      1. 已分配和未分配的内存块位于同一个链表中，每次分配都需要从头到尾遍历      2. 采用首次适应法，内存块会被整体分配，容易产生较多内部碎片  - 看看newbing怎么说                  
      "></a>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384022573">https://zhuanlan.zhihu.com/p/384022573</a><br><br>  - malloc原理 空闲链表 整块分配(不是唯一的方法) 【方法2是 空闲链表+按需分配】<br><br>      ### <strong>malloc 的实现方式一：显式空闲链表 + 整块分配</strong><br><br>      <code>malloc</code> 的实现方式有很多种。最简单的方法是使用一个链表来管理所有已分配和未分配的内存块，在每个内存块的首部记录当前块的大小、当前区块是否已经被分配出去。首部对应这样的结构体：<br><br>      <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">**<span class="hljs-class"><span class="hljs-keyword">struct</span>** **<span class="hljs-title">mem_control_block</span>** &#123;</span><br>  **<span class="hljs-type">int</span>** is_available; *<span class="hljs-comment">// 是否可用（如果还没被分配出去，就是 1）*</span><br>  **<span class="hljs-type">int</span>** size;         *<span class="hljs-comment">// 实际空间的大小*</span><br>&#125;;<br></code></pre></td></tr></table></figure><br><br>      使用首次适应法进行分配：遍历整个链表，找到第一个未被分配、大小合适的内存块；如果没有这样的内存块，则向操作系统申请扩展堆内存。<br><br>      源码<br><br>      <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> has_initialized = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 初始化标志</span><br><span class="hljs-type">void</span> *managed_memory_start;  <span class="hljs-comment">// 指向堆底（内存块起始位置）</span><br><span class="hljs-type">void</span> *last_valid_address;    <span class="hljs-comment">// 指向堆顶</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">malloc_init</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 这里不向操作系统申请堆空间，只是为了获取堆的起始地址</span><br>  last_valid_address = sbrk(<span class="hljs-number">0</span>);<br>  managed_memory_start = last_valid_address;<br>  has_initialized = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">long</span> numbytes)</span> &#123;<br>  <span class="hljs-type">void</span> *current_location;  <span class="hljs-comment">// 当前访问的内存位置</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_control_block</span> *<span class="hljs-title">current_location_mcb</span>;</span>  <span class="hljs-comment">// 只是作了一个强制类型转换</span><br>  <span class="hljs-type">void</span> *memory_location;  <span class="hljs-comment">// 这是要返回的内存位置。初始时设为</span><br>                          <span class="hljs-comment">// 0，表示没有找到合适的位置</span><br>  <span class="hljs-keyword">if</span> (!has_initialized) &#123;<br>    malloc_init();<br>  &#125;<br>  <span class="hljs-comment">// 要查找的内存必须包含内存控制块，所以需要调整 numbytes 的大小</span><br>  numbytes = numbytes + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mem_control_block);<br>  <span class="hljs-comment">// 初始时设为 0，表示没有找到合适的位置</span><br>  memory_location = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* Begin searching at the start of managed memory */</span><br>  <span class="hljs-comment">// 从被管理内存的起始位置开始搜索</span><br>  <span class="hljs-comment">// managed_memory_start 是在 malloc_init 中通过 sbrk() 函数设置的</span><br>  current_location = managed_memory_start;<br>  <span class="hljs-keyword">while</span> (current_location != last_valid_address) &#123;<br>    <span class="hljs-comment">// current_location 是一个 void 指针，用来计算地址；</span><br>    <span class="hljs-comment">// current_location_mcb 是一个具体的结构体类型</span><br>    <span class="hljs-comment">// 这两个实际上是一个含义</span><br>    current_location_mcb = (<span class="hljs-keyword">struct</span> mem_control_block *)current_location;<br>    <span class="hljs-keyword">if</span> (current_location_mcb-&gt;is_available) &#123;<br>      <span class="hljs-keyword">if</span> (current_location_mcb-&gt;size &gt;= numbytes) &#123;<br>        <span class="hljs-comment">// 找到一个可用、大小适合的内存块</span><br>        current_location_mcb-&gt;is_available = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 设为不可用</span><br>        memory_location = current_location;      <span class="hljs-comment">// 设置内存地址</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 否则，当前内存块不可用或过小，移动到下一个内存块</span><br>    current_location = current_location + current_location_mcb-&gt;size;<br>  &#125;<br>  <span class="hljs-comment">// 循环结束，没有找到合适的位置，需要向操作系统申请更多内存</span><br>  <span class="hljs-keyword">if</span> (!memory_location) &#123;<br>    <span class="hljs-comment">// 扩展堆</span><br>    sbrk(numbytes);<br>    <span class="hljs-comment">// 新的内存的起始位置就是 last_valid_address 的旧值</span><br>    memory_location = last_valid_address;<br>    <span class="hljs-comment">// 将 last_valid_address 后移 numbytes，移动到整个内存的最右边界</span><br>    last_valid_address = last_valid_address + numbytes;<br>    <span class="hljs-comment">// 初始化内存控制块 mem_control_block</span><br>    current_location_mcb = memory_location;<br>    current_location_mcb-&gt;is_available = <span class="hljs-number">0</span>;<br>    current_location_mcb-&gt;size = numbytes;<br>  &#125;<br>  <span class="hljs-comment">// 最终，memory_location 保存了大小为 numbyte的内存空间，</span><br>  <span class="hljs-comment">// 并且在空间的开始处包含了一个内存控制块，记录了元信息</span><br>  <span class="hljs-comment">// 内存控制块对于用户而言应该是透明的，因此返回指针前，跳过内存分配块</span><br>  memory_location = memory_location + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mem_control_block);<br>  <span class="hljs-comment">// 返回内存块的指针</span><br>  <span class="hljs-keyword">return</span> memory_location;<br>&#125;<br></code></pre></td></tr></table></figure><br><br>  - 这个 方法的缺陷：<br><br>      这种方法的缺点是：<br><br>      1. 已分配和未分配的内存块位于同一个链表中，每次分配都需要从头到尾遍历<br>      2. 采用首次适应法，内存块会被整体分配，容易产生较多内部碎片<br><br>  - 看看newbing怎么说<br><br>      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abap">        <br></code></pre></td></tr></table></figure><br><br>      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs abap">你好，这是Bing。我很高兴为你解答关于C语言中 malloc 和 free 的原理的问题。😊<br><br>malloc 和 free 是两个用于动态内存分配和释放的函数，它们可以让程序在运行时根据需要申请或回收一段连续的内存空间¹。<br><br>malloc 的函数原型是 `void *malloc (size_t size)`，它的参数是要分配的内存大小（以字节为单位），它的返回值是一个指向分配内存的起始地址的指针，如果分配失败则返回 NULL²。<br><br>free 的函数原型是 `void free (void *ptr)`，它的参数是一个指向要释放的内存块的指针，它没有返回值²。<br><br>malloc 和 free 的工作原理大致如下：<br><br>- malloc 和 free 都是基于操作系统提供的系统调用（如 brk 或 mmap）来管理堆（heap）上的内存空间³。<br>- 堆是一个动态增长或缩小的内存区域，它由一个 break 指针来标记其边界³。当堆上的可用空间不足时，malloc 会调用系统调用来增加 break 指针的位置，从而扩大堆的大小³。<br>- malloc 会将堆上的内存空间以块（block）的形式组织起来，每个块由元数据区和数据区组成⁴。元数据区记录了块的大小、是否空闲、指向下一个块的指针等信息⁴。数据区则是实际分配给程序使用的内存区域⁴。<br>- malloc 在分配内存时，会从堆的起始地址开始遍历块链表，寻找第一个符合要求（空闲且大小不小于请求大小）的块，并将其标记为已分配⁴。如果找不到合适的块，malloc 会扩展堆并创建一个新的块来满足请求⁴。<br>- free 在释放内存时，会根据传入的指针找到对应的块，并将其标记为可用⁴。同时，free 会检查相邻的块是否也是空闲的，如果是，则将它们合并成一个更大的块，以减少内存碎片⁴。<br><br>简单通俗地说，malloc 和 free 就像是一个仓库管理员，他们可以根据客户的需求从仓库中拿出或放回一定数量的货物，并且保持仓库的整洁有序。😊<br><br>希望我的回答对你有帮助，如果你还有其他问题，请随时提问。👋<br><br>源: 与必应的对话， 2023/9/3<br>(1) C语言内存管理机制--malloc/calloc/free原理与实现 - 知乎. https://zhuanlan.zhihu.com/p/404081543.<br>(2) 浅谈malloc()与free() - 知乎. https://zhuanlan.zhihu.com/p/111776504.<br>(3) C语言的malloc()和free()函数原理【整理】 - CSDN博客. https://blog.csdn.net/llhyy17/article/details/5375298.<br>(4) malloc底层原理学习 - 知乎. https://zhuanlan.zhihu.com/p/105651237.<br>(5) 关于c语言内存分配,malloc,free,和段错误，内存泄露 - 阿里云 .... https://developer.aliyun.com/article/297006.<br></code></pre></td></tr></table></figure><br><br>      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs abap">“如果找不到合适的块，malloc 会扩展堆并创建一个新的块来满足请求”   这个又是啥<br><br>这个是指当堆上没有足够的空闲空间来分配给程序时，malloc 会向操作系统申请更多的内存，<br>然后在新的内存上创建一个大小合适的块，并返回它的地址。<br>这个过程叫做**堆的扩展**¹。**块的创建**就是在堆上划分出一段连续的内存空间，<br>并在其前面添加一些元数据来记录它的信息²。<br>你可以参考这篇文章¹来了解更多关于堆的扩展和块的创建的细节。😊<br><br>¹: [C语言实现创建堆(两种方式)_一个一个插入生成堆_你的代码 ...](^1^)<br>²: [什么是堆? 什么是栈？ - 知乎](^2^)<br><br>源: 与必应的对话， 2023/9/3<br>(1) C语言实现创建堆(两种方式)_一个一个插入生成堆_你的代码 .... https://blog.csdn.net/weixin_44915226/article/details/108165743.<br>(2) 什么是堆? 什么是栈？ - 知乎. https://zhuanlan.zhihu.com/p/101531768.<br>(3) C语言实现创建堆(两种方式)_一个一个插入生成堆_你的代码 .... https://blog.csdn.net/weixin_44915226/article/details/108165743.<br>(4) 什么是堆? 什么是栈？ - 知乎. https://zhuanlan.zhihu.com/p/101531768.<br>(5) 什么是堆？什么是栈？他们之间有什么区别和联系？ - 知乎. https://www.zhihu.com/question/19729973.<br></code></pre></td></tr></table></figure>
      </h2></li>
<li><p>栈溢出？</p>
<p>  堆向上生长，栈向下生长，栈指针和堆指针相遇的时候就会触发栈溢出。</p>
</li>
</ul>
<h2 id="数据结构与算法："><a href="#数据结构与算法：" class="headerlink" title="数据结构与算法："></a>数据结构与算法：</h2><ul>
<li><p>数组</p>
<ul>
<li><p>【1022】有序数组的平方：双指针法</p>
<p>  思路：双指针法；因为数组有正有负，让两个指针一个从头开始一个从尾开始，平方之后比较大小；较大的先放入新数组中；</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">sortedSquares</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> &#123;<br>        <span class="hljs-type">int</span> k = A.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">result</span><span class="hljs-params">(A.size(), <span class="hljs-number">0</span>)</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = A.size() - <span class="hljs-number">1</span>; i &lt;= j;) &#123; <span class="hljs-comment">// 注意这里要i &lt;= j，因为最后要处理两个元素</span><br>            <span class="hljs-keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j])  &#123;<br>                result[k--] = A[j] * A[j];<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result[k--] = A[i] * A[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>【1022】替换空格 ；双指针从后往前进行替换 可以提高效率；arr[ slow ] &#x3D; arr[ fast ]; 很难吗？</p>
<p>  请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>  示例 1： 输入：s &#x3D; “We are happy.”<br>  输出：”We%20are%20happy.”</p>
<p>  <img src="https://picgo-public-1215.oss-cn-shenzhen.aliyuncs.com/%25E6%259B%25BF%25E6%258D%25A2%25E7%25A9%25BA%25E6%25A0%25BC.gif" srcset="/img/loading.gif" lazyload alt="替换空格.gif"></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">string</span> <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计空格的个数</span><br>        <span class="hljs-type">int</span> sOldSize = s.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span><br>        s.resize(s.size() + count * <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> sNewSize = s.size();<br>        <span class="hljs-comment">// 从后先前将空格替换为&quot;%20&quot;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sNewSize - <span class="hljs-number">1</span>, j = sOldSize - <span class="hljs-number">1</span>; j &lt; i; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[i] = s[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li><p>对于Linux的简述</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abap">其次就是Linux，尽管投的是嵌入式单片机岗位，但嵌入式在广泛的一个定义里，<br>大家还是默认是以Linux为主，所以Linux的基础知识也要会，<br>因为有些公司在笔试的时候就会涉及到，这方面的话主要是要理解一些理论知识，<br>知道线程进程，知道一些基础的指令，最好可以在ubuntu上写一个代码出来gcc编译一下。【Makefile】<br>会这些Linux相关内容基本上就可以让你在笔试阶段不那么吃亏，<br>当然只会这些是不足以支撑你去找一个Linux岗位的工作的。<br></code></pre></td></tr></table></figure>
</li>
<li><p>Linux命令</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs abap">ls 查看目录<br>ls -a 显示目录所有文件及文件夹，包括隐藏文件，比如以.开头的<br>cd 目录切换<br>/ 根目录<br>../ 返回上一层目录<br>pwd 显示当前路径<br>cat 查看文件内容<br>touch 创建文件<br>cp 文件拷贝<br>rm 删除文件<br>rm -rf 删除文件夹（比rmdir好用）<br>mkdir 创建文件夹<br>rmdir 删除文件夹<br>mv 移动文件或用于重命名<br>reboot 重启<br>poweroff 关机<br>sync 数据同步进磁盘<br>find 查找文件<br>grep 查找文件内容<br>grep -i 区分大小写<br>clear 清屏<br>uname 系统信息查看命令<br>ifconfig 显示网络配置信息<br>su 切换用户命令<br>sudo 切换用户身份命令<br>man 系统帮助命令<br>du 文件夹大小查看命令<br>df 磁盘空间检查命令<br>ps 查看当前系统进程<br>top 进程实时运行状态查看命令<br>file 文件类型查看命令<br>chmod 修改文件权限<br>文件file1的访问权限为rw-r--r--，现要增加所有用户的执行权限和同组用户的权限<br>chmod a+x g+w file1 u：所有者 g:所在组 o：其他组 a：所有人(u、g、o的总和)<br>chmod 775 file1<br>rmmod 卸载内核<br>make 编译内核<br>useradd 新增用户<br><br>作者：A-Tang_<br>链接：https://www.nowcoder.com/discuss/353158977431216128<br>来源：牛客网<br></code></pre></td></tr></table></figure>
</li>
<li><p>Linux需要知道的知识点</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs abap">解决死锁的基本方法？<br>kmalloc、vmalloc、malloc的区别？<br>什么是进程？<br>什么是线程？<br>进程和线程的区别？<br>何时使用多进程？<br>何时使用多线程？<br>进程的五个状态？<br>进程间通信的方式有哪些？<br>【进程和线程的通信方式？】<br>线程间同步的方法？<br>如何确定当前线程是繁忙还是阻塞？<br>就绪状态的进程在等待什么？<br>怎么查看进程使用情况？<br>进程调度算法？<br>产生死锁的原因是什么？<br>死锁的4个必要条件？<br><br></code></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.notion.so/FreeRTOS-497ffd98755242c09007eca61dcbde10?pvs=21">用户态和内核态的区别：</a></li>
</ul>
</li>
</ul>
<h2 id="Autosar"><a href="#Autosar" class="headerlink" title="Autosar"></a>Autosar</h2><h1 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h1><ul>
<li>PID？</li>
<li>PID调参流程？</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>嵌入式秋招八股文</div>
      <div>http://example.com/2023/12/15/秋招八股文/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Banned104</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 15, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/15/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
